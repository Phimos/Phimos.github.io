<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://phimos.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Before start 以下是memlayout.h中对于虚拟地址空间布局的描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;* * Virtual memory map:">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828 Lab2">
<meta property="og:url" content="http://phimos.github.io/2020/03/30/6828-lab2/index.html">
<meta property="og:site_name" content="Pims的博客">
<meta property="og:description" content="Before start 以下是memlayout.h中对于虚拟地址空间布局的描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#x2F;* * Virtual memory map:">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/01/10/RlbTjedBpP9o2QO.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/01/10/AEWDsbFePZNw8Mq.jpg">
<meta property="og:image" content="https://s2.loli.net/2023/01/10/yLHc5X9f4QURwvD.jpg">
<meta property="article:published_time" content="2020-03-29T20:48:43.000Z">
<meta property="article:modified_time" content="2020-03-29T20:48:43.000Z">
<meta property="article:author" content="Pims">
<meta property="article:tag" content="6.828">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/01/10/RlbTjedBpP9o2QO.jpg">

<link rel="canonical" href="http://phimos.github.io/2020/03/30/6828-lab2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MIT6.828 Lab2 | Pims的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Pims的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pims的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://phimos.github.io/2020/03/30/6828-lab2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pims">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pims的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT6.828 Lab2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-30 04:48:43" itemprop="dateCreated datePublished" datetime="2020-03-30T04:48:43+08:00">2020-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="before-start"><a class="markdownIt-Anchor" href="#before-start"></a> Before start</h2>
<p>以下是memlayout.h中对于虚拟地址空间布局的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Virtual memory map:                                Permissions</span><br><span class="line"> *                                                    kernel/user</span><br><span class="line"> *</span><br><span class="line"> *    4 Gig --------&gt;  +------------------------------+</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     :              .               :</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~| RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *                     |   Remapped Physical Memory   | RW/--</span><br><span class="line"> *                     |                              | RW/--</span><br><span class="line"> *    KERNBASE, ----&gt;  +------------------------------+ 0xf0000000      --+</span><br><span class="line"> *    KSTACKTOP        |     CPU0&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     |     CPU1&#x27;s Kernel Stack      | RW/--  KSTKSIZE   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                 PTSIZE</span><br><span class="line"> *                     |      Invalid Memory (*)      | --/--  KSTKGAP    |</span><br><span class="line"> *                     +------------------------------+                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *                     :              .               :                   |</span><br><span class="line"> *    MMIOLIM ------&gt;  +------------------------------+ 0xefc00000      --+</span><br><span class="line"> *                     |       Memory-mapped I/O      | RW/--  PTSIZE</span><br><span class="line"> * ULIM, MMIOBASE --&gt;  +------------------------------+ 0xef800000</span><br><span class="line"> *                     |  Cur. Page Table (User R-)   | R-/R-  PTSIZE</span><br><span class="line"> *    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line"> *                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line"> *    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br><span class="line"> *                     |           RO ENVS            | R-/R-  PTSIZE</span><br><span class="line"> * UTOP,UENVS ------&gt;  +------------------------------+ 0xeec00000</span><br><span class="line"> * UXSTACKTOP -/       |     User Exception Stack     | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebff000</span><br><span class="line"> *                     |       Empty Memory (*)       | --/--  PGSIZE</span><br><span class="line"> *    USTACKTOP  ---&gt;  +------------------------------+ 0xeebfe000</span><br><span class="line"> *                     |      Normal User Stack       | RW/RW  PGSIZE</span><br><span class="line"> *                     +------------------------------+ 0xeebfd000</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     .                              .</span><br><span class="line"> *                     |~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~|</span><br><span class="line"> *                     |     Program Data &amp; Heap      |</span><br><span class="line"> *    UTEXT --------&gt;  +------------------------------+ 0x00800000</span><br><span class="line"> *    PFTEMP -------&gt;  |       Empty Memory (*)       |        PTSIZE</span><br><span class="line"> *                     |                              |</span><br><span class="line"> *    UTEMP --------&gt;  +------------------------------+ 0x00400000      --+</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *                     | - - - - - - - - - - - - - - -|                   |</span><br><span class="line"> *                     |  User STAB Data (optional)   |                 PTSIZE</span><br><span class="line"> *    USTABDATA ----&gt;  +------------------------------+ 0x00200000        |</span><br><span class="line"> *                     |       Empty Memory (*)       |                   |</span><br><span class="line"> *    0 ------------&gt;  +------------------------------+                 --+</span><br><span class="line"> *</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.  JOS user programs map pages temporarily at UTEMP.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>总体的虚拟内存布局是如上的一个状态。</p>
<p>在inc/mmu.h文件的注释中可以看到对于线性地址的结构描述如下，是按二级页表的方式进行地址转换的。前十位是一级页表的索引，中间十位是二级页表索引，最后的12位表示的是4K页面内部的偏移量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// A linear address &#x27;la&#x27; has a three-part structure as follows:</span><br><span class="line">//</span><br><span class="line">// +--------10------+-------10-------+---------12----------+</span><br><span class="line">// | Page Directory |   Page Table   | Offset within Page  |</span><br><span class="line">// |      Index     |      Index     |                     |</span><br><span class="line">// +----------------+----------------+---------------------+</span><br><span class="line">//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/</span><br><span class="line">//  \---------- PGNUM(la) ----------/</span><br></pre></td></tr></table></figure>
<p>在inc/memlayout.h中可以看到PageInfo的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> &#123;</span></span><br><span class="line">	<span class="comment">// Next page on the free list.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp_link</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pp_ref is the count of pointers (usually in page table entries)</span></span><br><span class="line">	<span class="comment">// to this page, for pages allocated using page_alloc.</span></span><br><span class="line">	<span class="comment">// Pages allocated at boot time using pmap.c&#x27;s</span></span><br><span class="line">	<span class="comment">// boot_alloc do not have valid reference count fields.</span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint16_t</span> pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中pp_link链接的是free list当中下一个空闲的页面，而pp_ref表示的是指向该页面的指针的个数，当清零的时候说明页面就没有被指向了。在全局是利用一个PageInfo的数组来存放物理页面状态：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pages</span>;</span></span><br></pre></td></tr></table></figure>
<p>可以发现页面是通过一个PageInfo类型进行描述，指针与pages地址的差值就是页面号，物理地址就直接是一个32-bit的整数，相互转换依照上方的三级结构进行:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (pp - pages) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> PageInfo*</span><br><span class="line"><span class="title function_">pa2page</span><span class="params">(<span class="type">physaddr_t</span> pa)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">		panic(<span class="string">&quot;pa2page called with invalid pa&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PGNUM(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以以上两个函数提供了一个在page和物理地址之间进行相互转换的方式。</p>
<h2 id="exercise-1"><a class="markdownIt-Anchor" href="#exercise-1"></a> Exercise 1</h2>
<h3 id="boot_alloc"><a class="markdownIt-Anchor" href="#boot_alloc"></a> boot_alloc</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This simple physical memory allocator is used only while JOS is setting</span></span><br><span class="line"><span class="comment">// up its virtual memory system.  page_alloc() is the real allocator.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n&gt;0, allocates enough pages of contiguous physical memory to hold &#x27;n&#x27;</span></span><br><span class="line"><span class="comment">// bytes.  Doesn&#x27;t initialize the memory.  Returns a kernel virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If n==0, returns the address of the next free page without allocating</span></span><br><span class="line"><span class="comment">// anything.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we&#x27;re out of memory, boot_alloc should panic.</span></span><br><span class="line"><span class="comment">// This function may ONLY be used during initialization,</span></span><br><span class="line"><span class="comment">// before the page_free_list list has been set up.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">boot_alloc</span><span class="params">(<span class="type">uint32_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> *nextfree;	<span class="comment">// virtual address of next byte of free memory</span></span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize nextfree if this is the first time.</span></span><br><span class="line">	<span class="comment">// &#x27;end&#x27; is a magic symbol automatically generated by the linker,</span></span><br><span class="line">	<span class="comment">// which points to the end of the kernel&#x27;s bss segment:</span></span><br><span class="line">	<span class="comment">// the first virtual address that the linker did *not* assign</span></span><br><span class="line">	<span class="comment">// to any kernel code or global variables.</span></span><br><span class="line">	<span class="keyword">if</span> (!nextfree) &#123;</span><br><span class="line">		<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">		nextfree = ROUNDUP((<span class="type">char</span> *) end, PGSIZE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span></span><br><span class="line">	<span class="comment">// nextfree.  Make sure nextfree is kept aligned</span></span><br><span class="line">	<span class="comment">// to a multiple of PGSIZE.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 2: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(npages * PGSIZE &lt; (<span class="type">uint32_t</span>)(nextfree + n - KERNBASE)) <span class="comment">// out of memory</span></span><br><span class="line">		panic(<span class="string">&quot;boot_alloc: We are out of memory.\n&quot;</span>);</span><br><span class="line">	result = nextfree;</span><br><span class="line">	nextfree = ROUNDUP(nextfree + n, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从34行开始为补充的代码部分，nextfree作为static变量只会初始化一次，用来表示往后第一个没有被分配的virtual address。</p>
<p>由于在注释中要求要对于对于out of memory的情况需要触发panic，所以这里在34行进行了一个分配内容是否超过物理内存限制的检查。如果一切正常的话就进行分配，采用已经定义好的ROUNDUP宏来进行页面对齐。</p>
<p>如果n为0的时候，37行代码不会产生任何改变，符合注释中所描述的代码逻辑。</p>
<h3 id="mem_init"><a class="markdownIt-Anchor" href="#mem_init"></a> mem_init</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span></span><br><span class="line"><span class="comment">// The kernel uses this array to keep track of physical pages: for</span></span><br><span class="line"><span class="comment">// each physical page, there is a corresponding struct PageInfo in this</span></span><br><span class="line"><span class="comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span></span><br><span class="line"><span class="comment">// to initialize all fields of each struct PageInfo to 0.</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"></span><br><span class="line">pages = (<span class="keyword">struct</span> PageInfo *) boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo) * npages);</span><br><span class="line"><span class="built_in">memset</span>(pages, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo)*npages);</span><br></pre></td></tr></table></figure>
<p>这里所需要进行的就是对于pages这样一个存储PageInfo的数组进行空间分配，并且初始化为0。首先先利用boot_alloc进行空间的分配，之后利用memset进行清零就可以了。</p>
<p>这里可以看到，pages实际上就是在页目录之后进行分配的一串物理地址。</p>
<p><img src="https://s2.loli.net/2023/01/10/RlbTjedBpP9o2QO.jpg" alt="" /></p>
<h3 id="page_init"><a class="markdownIt-Anchor" href="#page_init"></a> page_init</h3>
<p>在memlayout.h中可以看到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// At IOPHYSMEM (640K) there is a 384K hole for I/O.  From the kernel,</span></span><br><span class="line"><span class="comment">// IOPHYSMEM can be addressed at KERNBASE + IOPHYSMEM.  The hole ends</span></span><br><span class="line"><span class="comment">// at physical address EXTPHYSMEM.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOPHYSMEM	0x0A0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTPHYSMEM	0x100000</span></span><br></pre></td></tr></table></figure>
<p>IOPHYSMEM对应的是640K的位置，EXTPHYSMEM对应的是1M的位置。在lab1当中内核代码就是被加载到了1M的后面，之后再之前的<code>mem_init()</code>当中，我们又在上面进行了pages的分配，当前可以使用的free空间应当是从之前分配的内容后面开始。<code>boot_alloc()</code>返回的是一个<em>kernel virtual address</em>，需要将其转换得到对应的<em>physical address</em>。</p>
<p>从pmap.h文件中可以看到从PA向KVA的转换如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This macro takes a physical address and returns the corresponding kernel</span></span><br><span class="line"><span class="comment"> * virtual address.  It panics if you pass an invalid physical address. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KADDR(pa) _kaddr(__FILE__, __LINE__, pa)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span>*</span><br><span class="line">_kaddr(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">physaddr_t</span> pa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (PGNUM(pa) &gt;= npages)</span><br><span class="line">		_panic(file, line, <span class="string">&quot;KADDR called with invalid pa %08lx&quot;</span>, pa);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)(pa + KERNBASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么从KVA向PA的转换只需要进行一个逆操作。</p>
<p>最后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize page structure and memory free list.</span></span><br><span class="line"><span class="comment">// After this is done, NEVER use boot_alloc again.  ONLY use the page</span></span><br><span class="line"><span class="comment">// allocator functions below to allocate and deallocate physical</span></span><br><span class="line"><span class="comment">// memory via the page_free_list.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">	<span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">	<span class="comment">//     is free.</span></span><br><span class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">	<span class="comment">//     never be allocated.</span></span><br><span class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">	<span class="comment">//     page tables and other data structures?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Change the code to reflect this.</span></span><br><span class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">	<span class="comment">// free pages!</span></span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="type">uint32_t</span> pa_free_start = (<span class="type">uint32_t</span>)((<span class="type">char</span> *)boot_alloc(<span class="number">0</span>) - KERNBASE);</span><br><span class="line">	<span class="comment">// case 1:</span></span><br><span class="line">	pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">	pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// case 2, 3, 4:</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(IOPHYSMEM &lt;= i * PGSIZE &amp;&amp; i * PGSIZE &lt; pa_free_start)</span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">			pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">			pages[i].pp_link = page_free_list;</span><br><span class="line">			page_free_list = &amp;pages[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pa_free_start表示，这个物理地址后面的空间在当前都是空闲的，所以3和4的一部分都需要被设置成已经分配的状态。剩下的内容都被设置成空闲页面，加入到page_free_list当中。</p>
<h3 id="page_alloc"><a class="markdownIt-Anchor" href="#page_alloc"></a> page_alloc</h3>
<p>这里完成的是对于页面的分配，根据alloc_flags来判断是否对于页面进行初始化。如果进行分配的话，那么就将page_free_list的头一个页面取出进行分配即可，初始化利用page2kva得到对应的地址，然后进行初始化操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a physical page.  If (alloc_flags &amp; ALLOC_ZERO), fills the entire</span></span><br><span class="line"><span class="comment">// returned physical page with &#x27;\0&#x27; bytes.  Does NOT increment the reference</span></span><br><span class="line"><span class="comment">// count of the page - the caller must do these if necessary (either explicitly</span></span><br><span class="line"><span class="comment">// or via page_insert).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to set the pp_link field of the allocated page to NULL so</span></span><br><span class="line"><span class="comment">// page_free can check for double-free bugs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns NULL if out of free memory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: use page2kva and memset</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_alloc</span><span class="params">(<span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">alloc_page</span> =</span> page_free_list;</span><br><span class="line">	<span class="keyword">if</span>(alloc_page == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	page_free_list = alloc_page-&gt;pp_link;</span><br><span class="line">	alloc_page-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span>(alloc_flags &amp;&amp; ALLOC_ZERO)</span><br><span class="line">		<span class="built_in">memset</span>(page2kva(alloc_page), <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> alloc_page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="page_free"><a class="markdownIt-Anchor" href="#page_free"></a> page_free</h3>
<p>这里做的操作是释放页面，将页面插入page_free_list的头部就可以，但是首先需要检查是否pp_ref为0且pp_link为_NULL，前者不为0表示对于仍在使用的页面进行了释放的操作，后者不为NULL说明它本身就已经是被释放的页面，进行了double free的操作，都要触发panic。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return a page to the free list.</span></span><br><span class="line"><span class="comment">// (This function should only be called when pp-&gt;pp_ref reaches 0.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> PageInfo *pp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line">	<span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line">	<span class="keyword">if</span>(pp-&gt;pp_ref != <span class="number">0</span> || pp-&gt;pp_link != <span class="literal">NULL</span>)</span><br><span class="line">		panic(<span class="string">&quot;page_free: pp_ref or pp_link is not zero!\n&quot;</span>);</span><br><span class="line">	pp-&gt;pp_link = page_free_list;</span><br><span class="line">	page_free_list = pp;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里可以得到如下的输出内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br></pre></td></tr></table></figure>
<p>说明关于page_free_list的维护和page_alloc的操作都没有问题。</p>
<h2 id="exercise-2"><a class="markdownIt-Anchor" href="#exercise-2"></a> Exercise 2</h2>
<p>主要是关于Intel 80386手册的描述，其中第五章主要是对分段机制的描述，第六章是对分页机制的描述。由于在JOS当中将整个空间看做一个段，所以段偏移量就是线性地址，只需要明白关于分页机制以及对应的线性地址转换到物理地址的过程就好。</p>
<h2 id="exercise-3"><a class="markdownIt-Anchor" href="#exercise-3"></a> Exercise 3</h2>
<p>主要是GDB和QEMU命令的熟悉。</p>
<h2 id="exercise-4"><a class="markdownIt-Anchor" href="#exercise-4"></a> Exercise 4</h2>
<h3 id="pgdir_walk"><a class="markdownIt-Anchor" href="#pgdir_walk"></a> pgdir_walk</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given &#x27;pgdir&#x27;, a pointer to a page directory, pgdir_walk returns</span></span><br><span class="line"><span class="comment">// a pointer to the page table entry (PTE) for linear address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// This requires walking the two-level page table structure.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The relevant page table page might not exist yet.</span></span><br><span class="line"><span class="comment">// If this is true, and create == false, then pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">// Otherwise, pgdir_walk allocates a new page table page with page_alloc.</span></span><br><span class="line"><span class="comment">//    - If the allocation fails, pgdir_walk returns NULL.</span></span><br><span class="line"><span class="comment">//    - Otherwise, the new page&#x27;s reference count is incremented,</span></span><br><span class="line"><span class="comment">//	the page is cleared,</span></span><br><span class="line"><span class="comment">//	and pgdir_walk returns a pointer into the new page table page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 1: you can turn a PageInfo * into the physical address of the</span></span><br><span class="line"><span class="comment">// page it refers to with page2pa() from kern/pmap.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 2: the x86 MMU checks permission bits in both the page directory</span></span><br><span class="line"><span class="comment">// and the page table, so it&#x27;s safe to leave permissions in the page</span></span><br><span class="line"><span class="comment">// directory more permissive than strictly necessary.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint 3: look at inc/mmu.h for useful macros that manipulate page</span></span><br><span class="line"><span class="comment">// table and page directory entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">uint32_t</span> pdx = PDX(va);</span><br><span class="line">	<span class="type">uint32_t</span> ptx = PTX(va);</span><br><span class="line">	<span class="keyword">if</span>(pgdir[pdx] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(create)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">newpte</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(newpte == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			++(newpte-&gt;pp_ref);</span><br><span class="line">			pgdir[pdx] = page2pa(newpte) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pte = PTE_ADDR(pgdir[pdx]) | (ptx &lt;&lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> KADDR(pte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pgdir_walk()</code>函数做的内容实际上是通过虚拟地址va来进行一个地址翻译，找到所对应的pte。这里传入的三个参数，pgdir是一个指向页目录基址的指针，va是要进行翻译的虚拟地址，create是一个标志，如果非0说明对于对应的va不存在pte的话需要进行分配。</p>
<p>那么首先检查就是页目录中对应的页表到底存在不存在，如果存在的话，直接取出然后进行pte的计算。那么如果不存在的话，就需要page_alloc来分配一个物理页面用来存储页表，并且将该物理页面的引用添加，之后由于关于权限的确认在后面的pte项当中也会进行，所以这里关于页表就可以直接提供全部的权限，将其填入对应的页目录的项中。</p>
<p>那创建了页表之后，就如同之前一样进行进一步的地址转换。但是由于这里物理地址是不能直接进行解引用操作的，所以利用<code>KADDR</code>宏将得到的物理地址转换成remap过的虚拟地址，这样可以通过解引用来获得对应的物理地址也能对于所存储的内容进行修改。</p>
<h3 id="boot_map_region"><a class="markdownIt-Anchor" href="#boot_map_region"></a> boot_map_region</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map [va, va+size) of virtual address space to physical [pa, pa+size)</span></span><br><span class="line"><span class="comment">// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and</span></span><br><span class="line"><span class="comment">// va and pa are both page-aligned.</span></span><br><span class="line"><span class="comment">// Use permission bits perm|PTE_P for the entries.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function is only intended to set up the ``static&#x27;&#x27; mappings</span></span><br><span class="line"><span class="comment">// above UTOP. As such, it should *not* change the pp_ref field on the</span></span><br><span class="line"><span class="comment">// mapped pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">pte_t</span>* pte = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">			panic(<span class="string">&quot;boot_map_region: Fail to alloc new page, run out of memory!\n&quot;</span>);</span><br><span class="line">		*pte = pa | perm | PTE_P;</span><br><span class="line">		size -= PGSIZE;</span><br><span class="line">		va += PGSIZE, pa += PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个函数的作用是将一串连续的虚拟地址映射到一串连续的物理地址，其中映射的地址的大小是页面大小的整数倍。那么可以知道，直接的想法就是通过虚拟地址进行地址查询，然后将页表中对应的表项修改为映射到的物理地址就可以了。那么以每个页面单位来进行这样的操作。</p>
<p>首先通过<code>pgdir_walk()</code>来找到虚拟地址对应的表项，如果对应的二级页表不存在那么就进行空间的分配，如果分配失败则进行报错，出发一个panic。</p>
<p>之后就将物理地址以及对应的权限填到表项里面，然后对下一个需要映射的页进行相同的操作。</p>
<h3 id="page_lookup"><a class="markdownIt-Anchor" href="#page_lookup"></a> page_lookup</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return the page mapped at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If pte_store is not zero, then we store in it the address</span></span><br><span class="line"><span class="comment">// of the pte for this page.  This is used by page_remove and</span></span><br><span class="line"><span class="comment">// can be used to verify page permissions for syscall arguments,</span></span><br><span class="line"><span class="comment">// but should not be used by most callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return NULL if there is no page mapped at va.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: the TA solution uses pgdir_walk and pa2page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">struct</span> PageInfo *</span><br><span class="line"><span class="title function_">page_lookup</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va, <span class="type">pte_t</span> **pte_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span>* pte = pgdir_walk(pgdir, va, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = PTE_ADDR(*pte);</span><br><span class="line">	<span class="keyword">if</span>(pte_store)</span><br><span class="line">		*pte_store = pte;</span><br><span class="line">	<span class="keyword">return</span> pa2page(pa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方的<code>page_lookup()</code>想要做的是通过虚拟地址va来查找对应的映射页的PageInfo结构，这边的操作就是首先去找pte，如果找到说明该虚拟地址被映射到了一个页面，得到映射页面的物理页面首地址，再通过<code>pa2page()</code>完成转换。那么如果没有找到的话，说明这个虚拟地址并没有映射到任何物理页面。如果传入的pte_store非空的话，就将其进行保存。</p>
<h3 id="page_remove"><a class="markdownIt-Anchor" href="#page_remove"></a> page_remove</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unmaps the physical page at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// If there is no physical page at that address, silently does nothing.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Details:</span></span><br><span class="line"><span class="comment">//   - The ref count on the physical page should decrement.</span></span><br><span class="line"><span class="comment">//   - The physical page should be freed if the refcount reaches 0.</span></span><br><span class="line"><span class="comment">//   - The pg table entry corresponding to &#x27;va&#x27; should be set to 0.</span></span><br><span class="line"><span class="comment">//     (if such a PTE exists)</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if you remove an entry from</span></span><br><span class="line"><span class="comment">//     the page table.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using page_lookup,</span></span><br><span class="line"><span class="comment">// 	tlb_invalidate, and page_decref.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">page_remove</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span>* pte_store;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte_store);</span><br><span class="line">	<span class="keyword">if</span>(pp == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	*pte_store = <span class="number">0</span>;</span><br><span class="line">	page_decref(pp);</span><br><span class="line">	tlb_invalidate(pgdir, va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_remove()</code>所做的操作是将va映射到的物理页面给取消映射。要完成remove的操作需要做两件事情，一个就是将页表项中的对应内容给修改，另外一个就是对于PageInfo结构的修改，需要将其引用数减少，如果引用数为0，那么就将其加入空闲链表。在25行处的<code>page_decref()</code>函数做的实际上就是上述这个减少引用的操作。</p>
<p>那么一开始利用<code>page_lookup()</code>来找到对应的页面和pte，在24行修改pte，在25行修改链表结构，在26行调用<code>tlb_invalidate()</code>函数把TLB里面的内容给标注为无效。</p>
<h3 id="page_insert"><a class="markdownIt-Anchor" href="#page_insert"></a> page_insert</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map the physical page &#x27;pp&#x27; at virtual address &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">// The permissions (the low 12 bits) of the page table entry</span></span><br><span class="line"><span class="comment">// should be set to &#x27;perm|PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requirements</span></span><br><span class="line"><span class="comment">//   - If there is already a page mapped at &#x27;va&#x27;, it should be page_remove()d.</span></span><br><span class="line"><span class="comment">//   - If necessary, on demand, a page table should be allocated and inserted</span></span><br><span class="line"><span class="comment">//     into &#x27;pgdir&#x27;.</span></span><br><span class="line"><span class="comment">//   - pp-&gt;pp_ref should be incremented if the insertion succeeds.</span></span><br><span class="line"><span class="comment">//   - The TLB must be invalidated if a page was formerly present at &#x27;va&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Corner-case hint: Make sure to consider what happens when the same</span></span><br><span class="line"><span class="comment">// pp is re-inserted at the same virtual address in the same pgdir.</span></span><br><span class="line"><span class="comment">// However, try not to distinguish this case in your code, as this</span></span><br><span class="line"><span class="comment">// frequently leads to subtle bugs; there&#x27;s an elegant way to handle</span></span><br><span class="line"><span class="comment">// everything in one code path.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// RETURNS:</span></span><br><span class="line"><span class="comment">//   0 on success</span></span><br><span class="line"><span class="comment">//   -E_NO_MEM, if page table couldn&#x27;t be allocated</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The TA solution is implemented using pgdir_walk, page_remove,</span></span><br><span class="line"><span class="comment">// and page2pa.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">page_insert</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="keyword">struct</span> PageInfo *pp, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">pte_t</span>* pte = pgdir_walk(pgdir, va, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	<span class="type">physaddr_t</span> pa = page2pa(pp);</span><br><span class="line">	++(pp-&gt;pp_ref);</span><br><span class="line">	<span class="keyword">if</span>(*pte)</span><br><span class="line">		page_remove(pgdir, va);</span><br><span class="line">	*pte = pa | perm | PTE_P;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>page_insert()</code>的操作就是将va映射到pp所指向的物理页面上去，而对应的权限通过perm来进行表示。那么利用<code>pgdir_walk()</code>函数来获得pte, 如果没有就进行创建。那么这个情况下如果返回为NULL，只有可能是空间不足无法创建，于是返回-E_NO_MEM。那么如果能够得到pte，就对于对应的物理页面进行处理，添加引用数，然后把本来pte可能存在的映射关系给消除，之后再进行映射。</p>
<p>这里存在的一个问题是，如果我这里提供的pp本来就是va映射的对象，可能会出现问题。考虑将34行进行引用数增加的内容移到36行后面，那么他首先进行了page_remove。如果之前的引用数为1，那这个页面将被加入空闲链表。而之后再给他加了一个引用数，这就相当于空闲链表中存在着不空闲的页面，他可能会被二次分配。存在一个bug。而将该语句保存在34行的位置，就可以确保remove之后，如果本来就是va映射的页面，也不会被加入到空闲链表中，规避了之前所说的那种bug的出现。</p>
<h2 id="exercise-5"><a class="markdownIt-Anchor" href="#exercise-5"></a> Exercise 5</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UPAGES -- kernel R, user R</span></span><br><span class="line"><span class="comment">//      (ie. perm = PTE_U | PTE_P)</span></span><br><span class="line"><span class="comment">//    - pages itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">n = ROUNDUP(npages*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PageInfo), PGSIZE);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += PGSIZE)</span><br><span class="line">	page_insert(kern_pgdir, pa2page(PADDR(pages) + i), (<span class="type">void</span> *)(UPAGES + i), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure>
<p>这里是要将pages个映射到UPAGES以上的内容，那么这里要考虑到pages这整个内容实际上是对应着许多PageInfo结构的，在进行映射的同时需要对于PageInfo内部的引用数进行修改，这里采用一个for循环将所有页面依次进行映射。权限位由于在注释中说明，需要内核和用户都可读，所以标注成PTE_U|PTE_P。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span></span><br><span class="line"><span class="comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span></span><br><span class="line"><span class="comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">// to be the kernel stack, but break this into two pieces:</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span></span><br><span class="line"><span class="comment">//       the kernel overflows its stack, it will fault rather than</span></span><br><span class="line"><span class="comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line">boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</span><br></pre></td></tr></table></figure>
<p>这里进行的是一个连续地址的映射，完成的是内核栈的一个映射。这个地方被划分成了<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>和<code>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)</code>两个部分，通过注释内容可以知道，前一段是需要映射到物理地址的，后一段是不需要的。所以我们要做的只是将前一段进行映射。这里bootstack是已经知道的，通过PADDR将其转换为物理地址，然后映射以KSTACKTOP-KSTKSIZE为起点，KSTKSIZE大小的内容。权限由于在<code>boot_map_region()</code>当中会自动加上PTE_P，所以这里只要标注PTE_W。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map all of physical memory at KERNBASE.</span></span><br><span class="line"><span class="comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span></span><br><span class="line"><span class="comment">//      the PA range [0, 2^32 - KERNBASE)</span></span><br><span class="line"><span class="comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span></span><br><span class="line"><span class="comment">// we just set up the mapping anyway.</span></span><br><span class="line"><span class="comment">// Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// Your code goes here:</span></span><br><span class="line"><span class="comment">//cprintf(&quot;kernbase: %x 2^32-kernbase: %x&quot;, KERNBASE, (~KERNBASE)+1);</span></span><br><span class="line">boot_map_region(kern_pgdir, KERNBASE, (~KERNBASE) + <span class="number">1</span>, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>
<p>同样的是一个进行简单的连续地址映射的操作，那么这个地方也是采用<code>boot_map_region()</code>来进行，但是这里需要得到2^32，而32位大小是表示不出这么大的数的，所以这里采用<code>(~KERNBASE)+1</code>来得到需要进行映射的大小。这里的权限同样由于<code>boot_map_region()</code>会自动加上PTE_P，所以只需要标注PTE_W就可以了。</p>
<p>到这里为止，通过执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make grade</span><br></pre></td></tr></table></figure>
<p>可以得到如下的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">running JOS: (2.8s)</span><br><span class="line">  Physical page allocator: OK</span><br><span class="line">  Page management: OK</span><br><span class="line">  Kernel page directory: OK</span><br><span class="line">  Page management 2: OK</span><br><span class="line">Score: 70/70</span><br></pre></td></tr></table></figure>
<p>说明已经满足所有check函数的需求，完成了虚拟内存系统的一个初始化。</p>
<h2 id="questions"><a class="markdownIt-Anchor" href="#questions"></a> Questions：</h2>
<ul>
<li></li>
</ul>
<p><img src="https://s2.loli.net/2023/01/10/AEWDsbFePZNw8Mq.jpg" alt="" /></p>
<p>这里的value应当是一个虚拟地址，在程序里面，并不能直接对于物理地址进行操控，所有的指针都应当是虚拟地址。</p>
<p>这里需要注意的是：JOS将从0开始的所有物理内存映射到虚拟地址0xf0000000就是为了让内核能够读写只知道物理地址的内容。那么为了完成从物理地址到虚拟地址的转换，对于只知道物理地址的，就将其物理地址加上0xf0000000，就可以得到对应的虚拟地址了。利用定义好的宏<code>KADDA(pa)</code>可以做到，而宏<code>PADDA(va)</code>就是这个的逆操作。在Exercise4当中这两个宏能够有效地进行虚拟地址物理地址之间的转换，从而使的解引用等操作可以进行执行。</p>
<ul>
<li>表格如下：</li>
</ul>
<table>
<thead>
<tr>
<th>Entry</th>
<th>Base Virtual Address</th>
<th>Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td>960</td>
<td>0xf0000000</td>
<td>以上映射到物理地址从0开始的位置</td>
</tr>
<tr>
<td>959</td>
<td>0xefff8000</td>
<td>内核栈</td>
</tr>
<tr>
<td>958</td>
<td>0xef800000</td>
<td>页表（UVPT）</td>
</tr>
<tr>
<td>957</td>
<td>0xef400000</td>
<td>pages数组（UPAGES）</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>0</td>
<td>0x00000000</td>
<td>[see next question]</td>
</tr>
</tbody>
</table>
<ul>
<li>We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</li>
</ul>
<p>因为在表项中存在权限为，只有PTE_U被设置成1的时候才可以让user访问，kernel memory只需要修改权限为就可以不被user读写。</p>
<ul>
<li>What is the maximum amount of physical memory that this operating system can support? Why?</li>
</ul>
<p>在kern/pmap.c中的<code>mem_init()</code>函数中可以看到将pages数组映射到了线性地址的UPAGES上方。那么在inc/memlayout.h的图中可以看到，给只读的pages数组分配的空间为4M大小（一个PTSIZE）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*    UVPT      ----&gt;  +------------------------------+ 0xef400000</span><br><span class="line">*                     |          RO PAGES            | R-/R-  PTSIZE</span><br><span class="line">*    UPAGES    ----&gt;  +------------------------------+ 0xef000000</span><br></pre></td></tr></table></figure>
<p>一个PageInfo的大小是8Byte，一个页面的大小是4K。所以可以得到4M的pages数组对应的物理内存大小是：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mrow><mn>2</mn><mn>0</mn></mrow></msup></mrow><mrow><mn>8</mn></mrow></mfrac><mo>∗</mo><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mrow><mn>1</mn><mn>0</mn></mrow></msup><mo>=</mo><mn>2</mn><mo>∗</mo><msup><mn>2</mn><mrow><mn>3</mn><mn>0</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\frac{4*2^{20}}{8}*4*2^{10} = 2*2^{30}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.491108em;"></span><span class="strut bottom" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord reset-textstyle displaystyle textstyle uncramped"><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span><span class="mfrac"><span class="vlist"><span style="top:0.686em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle cramped"><span class="mord textstyle cramped"><span class="mord mathrm">8</span></span></span></span><span style="top:-0.22999999999999998em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped frac-line"></span></span><span style="top:-0.677em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle textstyle uncramped"><span class="mord textstyle uncramped"><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">2</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mbin">∗</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mbin">∗</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.413em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p>
<p>即操作系统能够支持的物理内存大小不会超过2G，理由如上。</p>
<ul>
<li>How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</li>
</ul>
<p>如果所有虚拟地址都被映射的话，那么页表的开销，一级页表需要1个page，二级页表需要1024个page。总共需要1025个page。所以页表上的开销为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>2</mn><mn>5</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>4</mn><mn>1</mn><mn>0</mn><mn>0</mn><mi>K</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">1025*4=4100KB</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">5</span><span class="mbin">∗</span><span class="mord mathrm">4</span><span class="mrel">=</span><span class="mord mathrm">4</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>。</p>
<p>采用大页可以减少开销，这样只需要一级页表就可以进行索引，需要一个page也就是4KB就可以了。</p>
<ul>
<li>Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</li>
</ul>
<p>在27行处利用<code>jmp	*%eax</code>进行了跳转，完成了在高地址执行的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.globl entry</span><br><span class="line">entry:</span><br><span class="line">	movw	$<span class="number">0x1234</span>,<span class="number">0x472</span>			<span class="meta"># warm boot</span></span><br><span class="line"></span><br><span class="line">	# We haven<span class="number">&#x27;</span>t <span class="built_in">set</span> up virtual memory yet, so we<span class="number">&#x27;</span>re running from</span><br><span class="line">	<span class="meta"># the physical address the boot loader loaded the kernel at: 1MB</span></span><br><span class="line">	# (plus a few bytes).  However, the C code is linked to run at</span><br><span class="line">	# KERNBASE+<span class="number">1</span>MB.  Hence, we <span class="built_in">set</span> up a trivial page directory that</span><br><span class="line">	<span class="meta"># translates virtual addresses [KERNBASE, KERNBASE+4MB) to</span></span><br><span class="line">	<span class="meta"># physical addresses [0, 4MB).  This 4MB region will be</span></span><br><span class="line">	<span class="meta"># sufficient until we set up our real page table in mem_init</span></span><br><span class="line">	<span class="meta"># in lab 2.</span></span><br><span class="line"></span><br><span class="line">	# Load the physical address of entry_pgdir into cr3.  entry_pgdir</span><br><span class="line">	<span class="meta"># is defined in entrypgdir.c.</span></span><br><span class="line">	movl	$(RELOC(entry_pgdir)), %eax</span><br><span class="line">	movl	%eax, %cr3</span><br><span class="line">	# Turn on paging.</span><br><span class="line">	movl	%cr0, %eax</span><br><span class="line">	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">	movl	%eax, %cr0</span><br><span class="line"></span><br><span class="line">	# Now paging is enabled, but we<span class="number">&#x27;</span>re still running at a low EIP</span><br><span class="line">	# (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="line">	# C code.</span><br><span class="line">	mov	$relocated, %eax</span><br><span class="line">	jmp	*%eax</span><br><span class="line">relocated:</span><br><span class="line"></span><br><span class="line">	# Clear the frame pointer <span class="title function_">register</span> <span class="params">(EBP)</span></span><br><span class="line">	<span class="meta"># so that once we get into debugging C code,</span></span><br><span class="line">	<span class="meta"># stack backtraces will be terminated properly.</span></span><br><span class="line">	movl	$0x0,%ebp			<span class="meta"># nuke frame pointer</span></span><br><span class="line"></span><br><span class="line">	# Set the <span class="built_in">stack</span> pointer</span><br><span class="line">	movl	$<span class="params">(bootstacktop)</span>,%esp</span><br><span class="line"></span><br><span class="line">	<span class="meta"># now to C code</span></span><br><span class="line">	call	i386_init</span><br></pre></td></tr></table></figure>
<p>同时在低EIP和高EIP访问的原因是，我们将虚拟地址的[0, 4MB)和[KERNBASE, KERNBASE+4MB)都映射到了物理地址的[0, 4MB)，所以无论从低地址还是高地址都可以进行访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__aligned__(PGSIZE)))</span><br><span class="line"><span class="type">pde_t</span> entry_pgdir[NPDENTRIES] = &#123;</span><br><span class="line">	<span class="comment">// Map VA&#x27;s [0, 4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">	[<span class="number">0</span>]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P,</span><br><span class="line">	<span class="comment">// Map VA&#x27;s [KERNBASE, KERNBASE+4MB) to PA&#x27;s [0, 4MB)</span></span><br><span class="line">	[KERNBASE&gt;&gt;PDXSHIFT]</span><br><span class="line">		= ((<span class="type">uintptr_t</span>)entry_pgtable - KERNBASE) + PTE_P + PTE_W</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从前面的内容可以看到，他在完成分页之后还有在低地址执行的语句，如果不同时将高地址和低地址都映射到物理地址的最低4M的话，那么在低地址运行的代码会出错。</p>
<h2 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h2>
<p>可以在inc/mmu.h当中找到关于PTE/PDE flag的描述，具体内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Page table/directory entry flags.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_P		0x001	<span class="comment">// Present</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W		0x002	<span class="comment">// Writeable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U		0x004	<span class="comment">// User</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PWT		0x008	<span class="comment">// Write-Through</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PCD		0x010	<span class="comment">// Cache-Disable</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A		0x020	<span class="comment">// Accessed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_D		0x040	<span class="comment">// Dirty</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_PS		0x080	<span class="comment">// Page Size</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_G		0x100	<span class="comment">// Global</span></span></span><br></pre></td></tr></table></figure>
<p>第九行所示的就是PTE_PS位，是用来调整Page Size大小的。</p>
<p>采用大页只有一级页表，对应的地址翻译方式如下：</p>
<img src="https://s2.loli.net/2023/01/10/yLHc5X9f4QURwvD.jpg" alt="image-20200310182755807" style="zoom:50%;" />
<p>通过Intel IA32手册3.6.1节关于Page Option的描述可以知道，需要开启cr4里面的PSE标志位，来说明提供对于大页的支持，在<code>mem_init()</code>当中添加如下代码进行实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set CR4_PSE</span></span><br><span class="line">cr4 = rcr4();</span><br><span class="line">cr4 |= CR4_PSE;</span><br><span class="line">lcr4(cr4);</span><br></pre></td></tr></table></figure>
<p>考虑到lab整体要对于这种大小页混合的方式进行适配的话，需要对于页面相关的许多函数进行重写。所以这里只考虑虚拟地址高256M到物理地址低256M的映射采用大页实现，只对于boot_map_region及其相关函数进行修改。</p>
<p>修改<code>pgdir_walk()</code>函数如下，其中normal状态是针对仅存在4K大小页的情况，而ex表示的是大小页混合状态的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk_normal</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="type">uint32_t</span> pdx = PDX(va);</span><br><span class="line">	<span class="type">uint32_t</span> ptx = PTX(va);</span><br><span class="line">	<span class="keyword">if</span>(pgdir[pdx] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(create)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">newpte</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(newpte == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			++(newpte-&gt;pp_ref);</span><br><span class="line">			pgdir[pdx] = page2pa(newpte) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pte = PTE_ADDR(pgdir[pdx]) | (ptx &lt;&lt; <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> KADDR(pte);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk_ex</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> pdx = PDX(va);</span><br><span class="line">	<span class="keyword">if</span>(pgdir[pdx] == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(create == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">newpte</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(newpte == <span class="literal">NULL</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">			++(newpte-&gt;pp_ref);</span><br><span class="line">			pgdir[pdx] = page2pa(newpte) | PTE_P | PTE_W | PTE_U;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(create == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pgdir[pdx] = PTE_PS;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(create == <span class="number">2</span> &amp;&amp; (!(pgdir[pdx] &amp; PTE_PS)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">struct</span> PageInfo * pp = pa2page(PTE_ADDR(pgdir[pdx]));</span><br><span class="line">		page_decref(pp);</span><br><span class="line">		tlb_invalidate(pgdir, (<span class="type">void</span>*)va);</span><br><span class="line">		pgdir[pdx] = PTE_PS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">uint32_t</span> pde = pgdir[pdx];</span><br><span class="line">	<span class="keyword">if</span>(pde &amp; PTE_PS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> pgdir + pdx;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> KADDR(PTE_ADDR(pgdir[pdx]) | (PTX(va) &lt;&lt; <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">pgdir_walk</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">int</span> create)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> size_ex = rcr4() &amp; CR4_PSE;</span><br><span class="line">	<span class="keyword">if</span>(size_ex)</span><br><span class="line">		<span class="keyword">return</span> pgdir_walk_normal(pgdir, va, create);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> pgdir_walk_ex(pgdir, va, create);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里仅仅对ex函数进行讨论，首先create可能为0、1或者2，不同于normal函数只存在0、1两种情况。0的时候表示不进行额外的分配。1的情况表示是一个小页，2的情况表示是一个大页，只要非0都是表示若不存在则进行分配。</p>
<p>那么如果当前当做一个大页的话，进行分配的情况不需要再去分配一个页面作为二级页表，只需要标记<code>PTE_PS</code>位返回填充对应的物理地址基址就好了。但是存在一个情况在于，原本这个pde指向的是一个二级页表，但是当前是采用大页进行分配的。所以在45行处有针对这种情况的特判。需要做的是将对应的二级页表的页面给清空，然后当做一个新分配的大页进行返回就可以了。</p>
<p>之后考虑的是<code>boot_map_region()</code>函数，同样重写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region_normal</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Fill this function in</span></span><br><span class="line">	<span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">pte_t</span>* pte = pgdir_walk(pgdir, (<span class="type">void</span> *)va, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">			panic(<span class="string">&quot;boot_map_region: Fail to alloc new page, run out of memory!\n&quot;</span>);</span><br><span class="line">		*pte = pa | perm | PTE_P;</span><br><span class="line">		size -= PGSIZE;</span><br><span class="line">		va += PGSIZE, pa += PGSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region_ex</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">pte_t</span>* pte = pgdir_walk_ex(pgdir, (<span class="type">void</span> *)va, <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">if</span>(pte == <span class="literal">NULL</span>)</span><br><span class="line">			panic(<span class="string">&quot;boot_map_region: Fail to alloc new page, run out of memory!\n&quot;</span>);</span><br><span class="line">		*pte = pa | perm | PTE_P | PTE_PS;</span><br><span class="line">		size -= PTSIZE;</span><br><span class="line">		va += PTSIZE, pa+= PTSIZE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">boot_map_region</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va, <span class="type">size_t</span> size, <span class="type">physaddr_t</span> pa, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> size_ex = rcr4() &amp; CR4_PSE;</span><br><span class="line">	<span class="keyword">if</span>(size_ex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ROUNDUP(pa, PTSIZE) &lt; ROUNDDOWN(pa+size, PTSIZE))</span><br><span class="line">		&#123;</span><br><span class="line">			boot_map_region_normal(pgdir, va, ROUNDUP(pa, PTSIZE) - pa, pa, perm);</span><br><span class="line">			boot_map_region_ex(pgdir, va+ROUNDUP(pa, PTSIZE)-pa, ROUNDDOWN(pa+size, PTSIZE) - ROUNDUP(pa, PTSIZE), ROUNDUP(pa, PTSIZE), perm);</span><br><span class="line">			boot_map_region_normal(pgdir, va+ROUNDDOWN(pa+size, PTSIZE)-pa, pa+size - ROUNDDOWN(pa+size, PTSIZE), ROUNDDOWN(pa+size, PTSIZE), perm);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			boot_map_region_normal(pgdir, va, size, pa, perm);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		boot_map_region_normal(pgdir, va, size, pa, perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里boot_map_region也被分成了两种情况，normal表示的是以4K为一个页面进行映射构造，ex表示的是以4M为一个页面大小进行映射构造。</p>
<p>在36行处的判断说明，仅当cr4被标识成拓展的页面大小且进行映射的区间内存在连续的4M空间的时候，对可以采用大页进行分配的部分采用大页，即调用<code>boot_map_region_ex()</code>函数。所以像是内核栈这种大小只有几十K的映射，在cr4设置之后仍然是采用原有的小页方法进行映射的。</p>
<p>这个时候采用原有的check函数会产生错误，原因在于原有的check函数所进行的地址转换方法是二级的。</p>
<p>重写原来给定的va2pa函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">physaddr_t</span></span><br><span class="line"><span class="title function_">check_va2pa</span><span class="params">(<span class="type">pde_t</span> *pgdir, <span class="type">uintptr_t</span> va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">pte_t</span> *p;</span><br><span class="line">	pgdir = &amp;pgdir[PDX(va)];</span><br><span class="line">	<span class="keyword">if</span>(!(*pgdir &amp; PTE_P))</span><br><span class="line">		<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((*pgdir &amp; PTE_PS))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> ((*pgdir) &amp; <span class="number">0xffc00000</span>) | (va &amp; <span class="number">0x3ff000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = (<span class="type">pte_t</span>*) KADDR(PTE_ADDR(*pgdir));</span><br><span class="line">		<span class="keyword">if</span> (!(p[PTX(va)] &amp; PTE_P))</span><br><span class="line">			<span class="keyword">return</span> ~<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> PTE_ADDR(p[PTX(va)]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据PTE_PS标志位来决定采用一级寻址还是二级寻址，这样就可以得到正常的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br><span class="line">check_kern_pgdir() succeeded!</span><br><span class="line">check_page_installed_pgdir() succeeded!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure>
<p>这里在清空cr4之后都是采用normal的方式来进行映射和寻址，所以会保持和原来相同的行为。</p>
<h2 id="challenge2"><a class="markdownIt-Anchor" href="#challenge2"></a> Challenge2</h2>
<h3 id="showmappings"><a class="markdownIt-Anchor" href="#showmappings"></a> showmappings</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"><span class="title function_">mon_showmappings</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;showmappings: should input 3 arguments!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">uint32_t</span> lowerbound = strtol(argv[<span class="number">1</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">	<span class="type">uint32_t</span> upperbound = strtol(argv[<span class="number">2</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">	<span class="type">uint32_t</span> va;</span><br><span class="line">	cprintf(<span class="string">&quot;Virtual Address\tPhysical Address\turw\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(va = ROUNDDOWN(lowerbound, PGSIZE); va &lt;= ROUNDUP(upperbound, PGSIZE); va += PGSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">pte_t</span> * pte = pgdir_walk(kern_pgdir, (<span class="type">void</span> *)va, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(pte &amp;&amp; ((*pte) &amp; PTE_P))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">physaddr_t</span> pa = PTE_ADDR(*pte);</span><br><span class="line">			<span class="type">char</span> perm_U = ((*pte) &amp; PTE_U) ? <span class="string">&#x27;u&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			<span class="type">char</span> perm_P = ((*pte) &amp; PTE_P) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			<span class="type">char</span> perm_W = ((*pte) &amp; PTE_W) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">			cprintf(<span class="string">&quot;  0x%08x\t  0x%08x\t%c%c%c\n&quot;</span> , va, pa, perm_U, perm_P, perm_W);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cprintf(<span class="string">&quot;  0x%08x\t  0x--------\t---\n&quot;</span>, va);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码如上，可以采用如下形式进行[start_va, end_va]区间内虚拟地址到物理地址页面映射的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmappings &lt;start_va&gt; &lt;end_va&gt;</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">K&gt; showmappings 0xefff0000 0xf0000000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xefff0000	       0x--------	     ---</span><br><span class="line">  0xefff1000	       0x--------	     ---</span><br><span class="line">  0xefff2000	       0x--------	     ---</span><br><span class="line">  0xefff3000	       0x--------	     ---</span><br><span class="line">  0xefff4000	       0x--------	     ---</span><br><span class="line">  0xefff5000	       0x--------	     ---</span><br><span class="line">  0xefff6000	       0x--------	     ---</span><br><span class="line">  0xefff7000	       0x--------	     ---</span><br><span class="line">  0xefff8000	       0x00117000	     -rw</span><br><span class="line">  0xefff9000	       0x00118000	     -rw</span><br><span class="line">  0xefffa000	       0x00119000	     -rw</span><br><span class="line">  0xefffb000	       0x0011a000	     -rw</span><br><span class="line">  0xefffc000	       0x0011b000	     -rw</span><br><span class="line">  0xefffd000	       0x0011c000	     -rw</span><br><span class="line">  0xefffe000	       0x0011d000	     -rw</span><br><span class="line">  0xeffff000	       0x0011e000	     -rw</span><br><span class="line">  0xf0000000	       0x00000000	     -rw</span><br></pre></td></tr></table></figure>
<h3 id="setperm"><a class="markdownIt-Anchor" href="#setperm"></a> setperm</h3>
<p>提供权限位的设置方法，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_setperm</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe * tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint32_t</span> va = strtol(argv[<span class="number">1</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		<span class="type">int</span> perm_U = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> perm_P = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> perm_W = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; argv[<span class="number">2</span>][i]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(argv[<span class="number">2</span>][i] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">				perm_U = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(argv[<span class="number">2</span>][i] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">				perm_P = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(argv[<span class="number">2</span>][i] == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">				perm_W = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">pte_t</span> * pte = pgdir_walk(kern_pgdir, (<span class="type">void</span> *)va, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(pte)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(perm_U)</span><br><span class="line">				*pte = (*pte) | PTE_U;</span><br><span class="line">			<span class="keyword">if</span>(perm_P)</span><br><span class="line">				*pte = (*pte) | PTE_P;</span><br><span class="line">			<span class="keyword">if</span>(perm_W)</span><br><span class="line">				*pte = (*pte) | PTE_W;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			cprintf(<span class="string">&quot;The virtual address 0x%08x is unmapped\n&quot;</span>, va);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(argc == <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint32_t</span> lowerbound = strtol(argv[<span class="number">1</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		<span class="type">uint32_t</span> upperbound = strtol(argv[<span class="number">2</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		<span class="type">int</span> perm_U = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> perm_P = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> perm_W = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> i, va;</span><br><span class="line">		<span class="keyword">for</span>(i = <span class="number">0</span>; argv[<span class="number">3</span>][i]; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(argv[<span class="number">3</span>][i] == <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">				perm_U = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(argv[<span class="number">3</span>][i] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">				perm_P = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(argv[<span class="number">3</span>][i] == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">				perm_W = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(va = ROUNDDOWN(lowerbound, PGSIZE); va &lt;= ROUNDUP(upperbound, PGSIZE); va += PGSIZE)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">pte_t</span> * pte = pgdir_walk(kern_pgdir, (<span class="type">void</span> *)va, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(pte)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(perm_U)</span><br><span class="line">					*pte = (*pte) | PTE_U;</span><br><span class="line">				<span class="keyword">if</span>(perm_P)</span><br><span class="line">					*pte = (*pte) | PTE_P;</span><br><span class="line">				<span class="keyword">if</span>(perm_W)</span><br><span class="line">					*pte = (*pte) | PTE_W;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cprintf(<span class="string">&quot;The virtual address 0x%08x is unmapped\n&quot;</span>, va);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;setperm: should give one address or an address range!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支持输入单个虚拟地址对对应的页表项进行更改，或者对一个虚拟地址区间进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setperm &lt;va&gt; &lt;perm&gt;</span><br><span class="line">setperm &lt;start_va&gt; &lt;end_va&gt; &lt;perm&gt;</span><br></pre></td></tr></table></figure>
<p>样例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -rw</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br><span class="line">K&gt; setperm 0xf0000000 u</span><br><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     urw</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br></pre></td></tr></table></figure>
<p>可以发现确实对权限位进行了设置。</p>
<h3 id="clearperm"><a class="markdownIt-Anchor" href="#clearperm"></a> clearperm</h3>
<p>对权限位进行清空，整体框架和setperm相同，只需要将修改部分的代码改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(perm_U)</span><br><span class="line">	*pte = (*pte) &amp; (~PTE_U);</span><br><span class="line"><span class="keyword">if</span>(perm_P)</span><br><span class="line">	*pte = (*pte) &amp; (~PTE_P);</span><br><span class="line"><span class="keyword">if</span>(perm_W)</span><br><span class="line">	*pte = (*pte) &amp; (~PTE_W);</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -rw</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br><span class="line">K&gt; clearperm 0xf0000000 w</span><br><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -r-</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br></pre></td></tr></table></figure>
<h3 id="changeperm"><a class="markdownIt-Anchor" href="#changeperm"></a> changeperm</h3>
<p>对权限位进行修改，整体框架和setperm相同，只需要将修改部分的代码改成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(perm_U)</span><br><span class="line">	*pte = (*pte) ^ PTE_U;</span><br><span class="line"><span class="keyword">if</span>(perm_P)</span><br><span class="line">	*pte = (*pte) ^ PTE_P;</span><br><span class="line"><span class="keyword">if</span>(perm_W)</span><br><span class="line">	*pte = (*pte) ^ PTE_W;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -rw</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br><span class="line">K&gt; changeperm 0xf0000000 w</span><br><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -r-</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br><span class="line">K&gt; changeperm 0xf0000000 w</span><br><span class="line">K&gt; showmappings 0xf0000000 0xf0001000</span><br><span class="line">Virtual Address	     Physical Address	     urw</span><br><span class="line">  0xf0000000	       0x00000000	     -rw</span><br><span class="line">  0xf0001000	       0x00001000	     -rw</span><br></pre></td></tr></table></figure>
<h3 id="content"><a class="markdownIt-Anchor" href="#content"></a> content</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_content</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc != <span class="number">4</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;content: type \&quot;help\&quot; to see the example!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">physaddr_t</span> pa;</span><br><span class="line">	<span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;v&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint32_t</span> base_va = strtol(argv[<span class="number">2</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">		<span class="type">pte_t</span> * pte = pgdir_walk(kern_pgdir, (<span class="type">void</span> *)base_va, <span class="number">0</span>);</span><br><span class="line">		pa = PTE_ADDR(*pte) | PGOFF(base_va);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		pa = strtol(argv[<span class="number">2</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">16</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;content: -p means physical address, -v means virtual address!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">uint32_t</span> count = strtol(argv[<span class="number">3</span>], <span class="string">&#x27;\0&#x27;</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="type">int</span> check;</span><br><span class="line">	<span class="keyword">for</span>(check = <span class="number">0</span>; count &gt; <span class="number">0</span>; --count, ++check)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(check == <span class="number">0</span>)</span><br><span class="line">			cprintf(<span class="string">&quot;0x%08x:&quot;</span>, pa);</span><br><span class="line">		cprintf(<span class="string">&quot; 0x%08x&quot;</span>, *(<span class="type">uint32_t</span>*)(KADDR(pa)));</span><br><span class="line">		pa += <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">if</span>(check == <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			check = <span class="number">-1</span>;</span><br><span class="line">			cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(check)</span><br><span class="line">		cprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码如上，用来查看虚拟地址或者物理地址对应的具体内容，可以利用如下的命令形式进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">content -p &lt;pa&gt; &lt;number&gt;</span><br><span class="line">content -v &lt;va&gt; &lt;number&gt;</span><br></pre></td></tr></table></figure>
<p>其中利用-p或者-v来表明查询的是物理地址还是虚拟地址，number表示要查询的多少，示例结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">K&gt; content -p 0x0 8</span><br><span class="line">0x00000000: 0xf000ff53 0xf000ff53 0xf000e2c3 0xf000ff53</span><br><span class="line">0x00000010: 0xf000ff53 0xf000ff54 0xf000ff53 0xf000ff53</span><br><span class="line">K&gt; content -v 0xf0000000 8</span><br><span class="line">0x00000000: 0xf000ff53 0xf000ff53 0xf000e2c3 0xf000ff53</span><br><span class="line">0x00000010: 0xf000ff53 0xf000ff54 0xf000ff53 0xf000ff53</span><br></pre></td></tr></table></figure>
<p>之前可以知道，KERNBASE以上的虚拟地址映射到的是从零开始的虚拟地址，所以上面得到的结果是完全相同的。利用qemu的指令进行检查：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(qemu) xp /8x 0x0</span><br><span class="line">0000000000000000: 0xf000ff53 0xf000ff53 0xf000e2c3 0xf000ff53</span><br><span class="line">0000000000000010: 0xf000ff53 0xf000ff54 0xf000ff53 0xf000ff53</span><br></pre></td></tr></table></figure>
<p>可以发现得到的结果完全相同，说明指令运行没有问题。</p>
<h2 id="challenge34"><a class="markdownIt-Anchor" href="#challenge34"></a> Challenge3&amp;4</h2>
<p>没写代码，感觉两个Challenge是递进的关系。challenge3可以考虑只保存包括内核自身的页目录，以及内核栈地址用来往内核栈写入参数保存信息，中断向量表等陷入内核态需要的信息。这样可能只需要几个page就足够了。陷入内核之后通过内核自身的页目录来完成地址映射进行寻址以及执行。这几个和内核相关的页面都应该是内核可读写，用户没有权限。</p>
<p>之后Challenge4由于Challenge3已经将内核相关的地址空间大小缩小了。如果进程想要对于这些地址进行分配的话，那么由于权限不够，会触发异常。处理的手段就是将这部分内容放到暂时还没有使用的地址，并且对相应的地址链接等内容进行修改，然后再次进行分配操作。我感觉这可能是bouncing kernel的意思，找了很久也没有找到bouncing kernel相关的资料或者论文。由于在challenge3当中把需要内核相关的内容缩小到了几个page，所以就可以大大减少需要触发弹跳机制的频率，降低为了更大地址空间所带来的额外时间开销。</p>
<h2 id="challenge5"><a class="markdownIt-Anchor" href="#challenge5"></a> Challenge5</h2>
<p>我觉得可以考虑采用类似ICS中malloc lab里面的方法，在PageInfo里面加入前后page的链接以及这个连续页面的大小（是PGSIZE的整数倍）。之后利用first-fit或者best-fit的方式进行适配，删除的时候考虑前后的合并。这样应该就可以完成连续地址的分配。对于比较大的连续分配还可以结合Challenge1当中的大页从而节省掉二级页表的空间。</p>
<p>题面中所说的&quot;power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice.&quot;应该就是伙伴系统了。感觉要完全实现除去修改自己写的函数之外需要修改<code>check_page_free_list()</code>以及<code>kern/pmap.h</code>当中的宏以及辅助函数，不知道会不会引发什么其他地方未知的错误，没有进行代码实现。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-828/" rel="tag"># 6.828</a>
              <a href="/tags/Operating-System/" rel="tag"># Operating System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/06/OpenMP-on-macOS/" rel="prev" title="在macOS 10.15上使用OpenMP">
      <i class="fa fa-chevron-left"></i> 在macOS 10.15上使用OpenMP
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/30/6828-lab3/" rel="next" title="MIT6.828 Lab3">
      MIT6.828 Lab3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#before-start"><span class="nav-number">1.</span> <span class="nav-text"> Before start</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-1"><span class="nav-number">2.</span> <span class="nav-text"> Exercise 1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#boot_alloc"><span class="nav-number">2.1.</span> <span class="nav-text"> boot_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mem_init"><span class="nav-number">2.2.</span> <span class="nav-text"> mem_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_init"><span class="nav-number">2.3.</span> <span class="nav-text"> page_init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_alloc"><span class="nav-number">2.4.</span> <span class="nav-text"> page_alloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_free"><span class="nav-number">2.5.</span> <span class="nav-text"> page_free</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-2"><span class="nav-number">3.</span> <span class="nav-text"> Exercise 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-3"><span class="nav-number">4.</span> <span class="nav-text"> Exercise 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-4"><span class="nav-number">5.</span> <span class="nav-text"> Exercise 4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pgdir_walk"><span class="nav-number">5.1.</span> <span class="nav-text"> pgdir_walk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#boot_map_region"><span class="nav-number">5.2.</span> <span class="nav-text"> boot_map_region</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_lookup"><span class="nav-number">5.3.</span> <span class="nav-text"> page_lookup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_remove"><span class="nav-number">5.4.</span> <span class="nav-text"> page_remove</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#page_insert"><span class="nav-number">5.5.</span> <span class="nav-text"> page_insert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-5"><span class="nav-number">6.</span> <span class="nav-text"> Exercise 5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#questions"><span class="nav-number">7.</span> <span class="nav-text"> Questions：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge"><span class="nav-number">8.</span> <span class="nav-text"> Challenge</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge2"><span class="nav-number">9.</span> <span class="nav-text"> Challenge2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#showmappings"><span class="nav-number">9.1.</span> <span class="nav-text"> showmappings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setperm"><span class="nav-number">9.2.</span> <span class="nav-text"> setperm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clearperm"><span class="nav-number">9.3.</span> <span class="nav-text"> clearperm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#changeperm"><span class="nav-number">9.4.</span> <span class="nav-text"> changeperm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#content"><span class="nav-number">9.5.</span> <span class="nav-text"> content</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge34"><span class="nav-number">10.</span> <span class="nav-text"> Challenge3&amp;4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge5"><span class="nav-number">11.</span> <span class="nav-text"> Challenge5</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pims</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pims</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
