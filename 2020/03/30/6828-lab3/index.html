<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://phimos.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Exercise 1 如同Exercise描述中所说的，类似pages分配的方法一样利用boot_alloc()就好，由于后面有env_init()函数负责结构体的初始化，这个地方不需要进行初始化的操作。 123&#x2F;&#x2F; Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828 Lab3">
<meta property="og:url" content="http://phimos.github.io/2020/03/30/6828-lab3/index.html">
<meta property="og:site_name" content="Pims的博客">
<meta property="og:description" content="Exercise 1 如同Exercise描述中所说的，类似pages分配的方法一样利用boot_alloc()就好，由于后面有env_init()函数负责结构体的初始化，这个地方不需要进行初始化的操作。 123&#x2F;&#x2F; Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-03-29T20:55:35.000Z">
<meta property="article:modified_time" content="2020-03-29T20:55:35.000Z">
<meta property="article:author" content="Pims">
<meta property="article:tag" content="6.828">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://phimos.github.io/2020/03/30/6828-lab3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MIT6.828 Lab3 | Pims的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Pims的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pims的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://phimos.github.io/2020/03/30/6828-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pims">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pims的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT6.828 Lab3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-30 04:55:35" itemprop="dateCreated datePublished" datetime="2020-03-30T04:55:35+08:00">2020-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="exercise-1"><a class="markdownIt-Anchor" href="#exercise-1"></a> Exercise 1</h2>
<p>如同Exercise描述中所说的，类似pages分配的方法一样利用<code>boot_alloc()</code>就好，由于后面有<code>env_init()</code>函数负责结构体的初始化，这个地方不需要进行初始化的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make &#x27;envs&#x27; point to an array of size &#x27;NENV&#x27; of &#x27;struct Env&#x27;.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">envs = (<span class="keyword">struct</span> Env *) boot_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br></pre></td></tr></table></figure>
<p>同时采用相似的方法将其map到UENVS处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the &#x27;envs&#x27; array read-only by the user at linear address UENVS</span></span><br><span class="line"><span class="comment">// (ie. perm = PTE_U | PTE_P).</span></span><br><span class="line"><span class="comment">// Permissions:</span></span><br><span class="line"><span class="comment">//    - the new image at UENVS  -- kernel R, user R</span></span><br><span class="line"><span class="comment">//    - envs itself -- kernel RW, user NONE</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">n = ROUNDUP(NENV*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), PGSIZE);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i+=PGSIZE)</span><br><span class="line">	page_insert(kern_pgdir, pa2page(PADDR(envs) + i), (<span class="type">void</span> *)(UENVS + i), PTE_U | PTE_P);</span><br></pre></td></tr></table></figure>
<h2 id="exericse-2"><a class="markdownIt-Anchor" href="#exericse-2"></a> Exericse 2</h2>
<h3 id="env_init"><a class="markdownIt-Anchor" href="#env_init"></a> env_init()</h3>
<p>这里的操作实际上就是进行一个envs的初始化，最开始所有的都是空闲状态，将其插入env_free_list就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all environments in &#x27;envs&#x27; as free, set their env_ids to 0,</span></span><br><span class="line"><span class="comment">// and insert them into the env_free_list.</span></span><br><span class="line"><span class="comment">// Make sure the environments are in the free list in the same order</span></span><br><span class="line"><span class="comment">// they are in the envs array (i.e., so that the first call to</span></span><br><span class="line"><span class="comment">// env_alloc() returns envs[0]).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Set up envs array</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="built_in">memset</span>(envs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env) * NENV);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	env_free_list = envs;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; NENV; ++i)</span><br><span class="line">		envs[i<span class="number">-1</span>].env_link = envs + i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">	env_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env_setup_vm"><a class="markdownIt-Anchor" href="#env_setup_vm"></a> env_setup_vm()</h3>
<p>这里可以知道，在UTOP下面应当是空白的，在UTOP上面都是相同的，所以首先对整个page进行清空，之后利用memcpy以kern_pgdir为模板，只需要进行page table的修改就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Initialize the kernel virtual memory layout for environment e.</span></span><br><span class="line"><span class="comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span></span><br><span class="line"><span class="comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">// Do NOT (yet) map anything into the user portion</span></span><br><span class="line"><span class="comment">// of the environment&#x27;s virtual address space.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if page directory or table could not be allocated.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page for the page directory</span></span><br><span class="line">	<span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line">	<span class="comment">//	(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line">	<span class="comment">//	See inc/memlayout.h for permissions and layout.</span></span><br><span class="line">	<span class="comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line">	<span class="comment">//	(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line">	<span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line">	<span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line">	<span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line">	<span class="comment">//	physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line">	<span class="comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line">	<span class="comment">//	pp_ref for env_free to work correctly.</span></span><br><span class="line">	<span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	e-&gt;env_pgdir = page2kva(p);</span><br><span class="line">	++(p-&gt;pp_ref);</span><br><span class="line">	<span class="built_in">memset</span>(e-&gt;env_pgdir, <span class="number">0</span>, PGSIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), kern_pgdir + PDX(UTOP), PGSIZE - (PDX(UTOP)&lt;&lt;<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line">	<span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="region_alloc"><a class="markdownIt-Anchor" href="#region_alloc"></a> region_alloc()</h3>
<p>这里可以仿照在pmap.c中多次实现的alloc操作，只不过这里的page是利用page_alloc()得到的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocate len bytes of physical memory for environment env,</span></span><br><span class="line"><span class="comment">// and map it at virtual address va in the environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">// Does not zero or otherwise initialize the mapped pages in any way.</span></span><br><span class="line"><span class="comment">// Pages should be writable by user and kernel.</span></span><br><span class="line"><span class="comment">// Panic if any allocation attempt fails.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">void</span> *va, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line">	<span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line">	<span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line">	<span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line">	<span class="type">void</span> *start_va = ROUNDDOWN(va, PGSIZE);</span><br><span class="line">	<span class="type">void</span> *end_va = ROUNDUP(va + len, PGSIZE);</span><br><span class="line">	<span class="type">void</span> *cur_va;</span><br><span class="line">	<span class="keyword">for</span>(cur_va = start_va; cur_va &lt; end_va; cur_va += PGSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pp</span> =</span> page_alloc(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>(!pp)</span><br><span class="line">			panic(<span class="string">&quot;region_alloc: Out of memory!\n&quot;</span>);</span><br><span class="line">		page_insert(e-&gt;env_pgdir, pp, (<span class="type">void</span> *)cur_va, PTE_U | PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="load_icode"><a class="markdownIt-Anchor" href="#load_icode"></a> load_icode()</h3>
<p>先看看<code>bootmain()</code>当中是怎么操作的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">bootmain</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// read 1st page off disk</span></span><br><span class="line">	readseg((<span class="type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// is this a valid ELF?</span></span><br><span class="line">	<span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line">		<span class="keyword">goto</span> bad;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *) ((<span class="type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">		<span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">		<span class="comment">// as the physical address)</span></span><br><span class="line">		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call the entry point from the ELF header</span></span><br><span class="line">	<span class="comment">// note: does not return!</span></span><br><span class="line">	((<span class="type">void</span> (*)(<span class="type">void</span>)) (ELFHDR-&gt;e_entry))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8A00</span>);</span><br><span class="line">	outw(<span class="number">0x8A00</span>, <span class="number">0x8E00</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">		<span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仿照第13-19行进行下面的code：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set up the initial program binary, stack, and processor flags</span></span><br><span class="line"><span class="comment">// for a user process.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function loads all loadable segments from the ELF binary image</span></span><br><span class="line"><span class="comment">// into the environment&#x27;s user memory, starting at the appropriate</span></span><br><span class="line"><span class="comment">// virtual addresses indicated in the ELF program header.</span></span><br><span class="line"><span class="comment">// At the same time it clears to zero any portions of these segments</span></span><br><span class="line"><span class="comment">// that are marked in the program header as being mapped</span></span><br><span class="line"><span class="comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All this is very similar to what our boot loader does, except the boot</span></span><br><span class="line"><span class="comment">// loader also needs to read the code from disk.  Take a look at</span></span><br><span class="line"><span class="comment">// boot/main.c to get ideas.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// load_icode panics if it encounters problems.</span></span><br><span class="line"><span class="comment">//  - How might load_icode fail?  What might be wrong with the given input?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">uint8_t</span> *binary)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line">	<span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line">	<span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line">	<span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line">	<span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line">	<span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line">	<span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line">	<span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line">	<span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line">	<span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line">	<span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line">	<span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line">	<span class="comment">//  the same virtual page.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line">	<span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line">	<span class="comment">//  So which page directory should be in force during</span></span><br><span class="line">	<span class="comment">//  this function?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line">	<span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line">	<span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Elf</span> * <span class="title">ELFHDR</span> =</span> (<span class="keyword">struct</span> Elf *)binary;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> * <span class="title">ph</span>, * <span class="title">eph</span>;</span></span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">	ph = (<span class="keyword">struct</span> Proghdr *)(binary + ELFHDR-&gt;e_phoff);</span><br><span class="line">	eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">	<span class="keyword">for</span>(; ph &lt; eph; ++ph)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)</span><br><span class="line">		&#123;</span><br><span class="line">			region_alloc(e, (<span class="type">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span> *)ph-&gt;p_va, <span class="number">0</span>, ph-&gt;p_memsz);</span><br><span class="line">			<span class="built_in">memcpy</span>((<span class="type">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_tf.tf_eip = ELFHDR-&gt;e_entry;</span><br><span class="line"></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	<span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line">	<span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	region_alloc(e, (<span class="type">void</span> *)(USTACKTOP - PGSIZE), PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env_create"><a class="markdownIt-Anchor" href="#env_create"></a> env_create()</h3>
<p>直接调用<code>env_alloc()</code>和<code>load_icode()</code>就可以了，可以看做是在上面的一层封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Allocates a new env with env_alloc, loads the named elf</span></span><br><span class="line"><span class="comment">// binary into it with load_icode, and sets its env_type.</span></span><br><span class="line"><span class="comment">// This function is ONLY called during kernel initialization,</span></span><br><span class="line"><span class="comment">// before running the first user-mode environment.</span></span><br><span class="line"><span class="comment">// The new env&#x27;s parent ID is set to 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_create</span><span class="params">(<span class="type">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e, <span class="number">0</span>))</span><br><span class="line">		panic(<span class="string">&quot;env_create: env alloc failed!\n&quot;</span>);</span><br><span class="line">	load_icode(e, binary);</span><br><span class="line">	e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="env_run"><a class="markdownIt-Anchor" href="#env_run"></a> env_run()</h3>
<p>要完成的是进行一个上下文的切换，这里主要做的就是首先对于env需要进行状态的改变，之后需要进行地址空间的切换。同时利用已经存在的<code>env_pop_tf()</code>函数来进行寄存器的恢复，具体的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Context switch from curenv to env e.</span></span><br><span class="line"><span class="comment">// Note: if this is the first call to env_run, curenv is NULL.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function does not return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line">	<span class="comment">//	   1. Set the current environment (if any) back to</span></span><br><span class="line">	<span class="comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line">	<span class="comment">//	      what other states it can be in),</span></span><br><span class="line">	<span class="comment">//	   2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line">	<span class="comment">//	   3. Set its status to ENV_RUNNING,</span></span><br><span class="line">	<span class="comment">//	   4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line">	<span class="comment">//	   5. Use lcr3() to switch to its address space.</span></span><br><span class="line">	<span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line">	<span class="comment">//	   registers and drop into user mode in the</span></span><br><span class="line">	<span class="comment">//	   environment.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line">	<span class="comment">//	and make sure you have set the relevant parts of</span></span><br><span class="line">	<span class="comment">//	e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">		curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	curenv = e;</span><br><span class="line">	e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">	++(e-&gt;env_runs);</span><br><span class="line">	lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">	env_pop_tf(&amp;(e-&gt;env_tf));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="gdb对hello进行断点调试"><a class="markdownIt-Anchor" href="#gdb对hello进行断点调试"></a> gdb对hello进行断点调试</h3>
<p>在obj/user/hello.asm里面可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">sys_cputs(const char *s, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  800a1c:	55                   	push   %ebp</span><br><span class="line">  800a1d:	89 e5                	mov    %esp,%ebp</span><br><span class="line">  800a1f:	57                   	push   %edi</span><br><span class="line">  800a20:	56                   	push   %esi</span><br><span class="line">  800a21:	53                   	push   %ebx</span><br><span class="line">	//</span><br><span class="line">	// The last clause tells the assembler that this can</span><br><span class="line">	// potentially change the condition codes and arbitrary</span><br><span class="line">	// memory locations.</span><br><span class="line"></span><br><span class="line">	asm volatile(&quot;int %1\n&quot;</span><br><span class="line">  800a22:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  800a27:	8b 4d 0c             	mov    0xc(%ebp),%ecx</span><br><span class="line">  800a2a:	8b 55 08             	mov    0x8(%ebp),%edx</span><br><span class="line">  800a2d:	89 c3                	mov    %eax,%ebx</span><br><span class="line">  800a2f:	89 c7                	mov    %eax,%edi</span><br><span class="line">  800a31:	89 c6                	mov    %eax,%esi</span><br><span class="line">  800a33:	cd 30                	int    $0x30</span><br></pre></td></tr></table></figure>
<p>对应的地址为0x800a33，利用gdb进行断点设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b *0x800a33</span><br><span class="line">Breakpoint 2 at 0x800a33</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">=&gt; 0x800a33:	int    $0x30</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00800a33 in ?? ()</span><br></pre></td></tr></table></figure>
<p>发现确实执行到了这一条指令，以上的实现应该是没有问题。</p>
<h2 id="exercise-3"><a class="markdownIt-Anchor" href="#exercise-3"></a> Exercise 3</h2>
<p>内容为阅读Chapter 9，是关于Exceptions和Interrupts的内容。</p>
<h2 id="exercise-4"><a class="markdownIt-Anchor" href="#exercise-4"></a> Exercise 4</h2>
<p>从inc/trap.h当中可以发现，TrapFrame有着如下的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PushRegs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">	<span class="type">uint16_t</span> tf_es;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding1;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ds;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding2;</span><br><span class="line">	<span class="type">uint32_t</span> tf_trapno;</span><br><span class="line">	<span class="comment">/* below here defined by x86 hardware */</span></span><br><span class="line">	<span class="type">uint32_t</span> tf_err;</span><br><span class="line">	<span class="type">uintptr_t</span> tf_eip;</span><br><span class="line">	<span class="type">uint16_t</span> tf_cs;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding3;</span><br><span class="line">	<span class="type">uint32_t</span> tf_eflags;</span><br><span class="line">	<span class="comment">/* below here only when crossing rings, such as from user to kernel */</span></span><br><span class="line">	<span class="type">uintptr_t</span> tf_esp;</span><br><span class="line">	<span class="type">uint16_t</span> tf_ss;</span><br><span class="line">	<span class="type">uint16_t</span> tf_padding4;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>可以知道对于剩下的就是要保存%es和%ds，来使得最终结构为一个<code>Trapframe</code>，剩下的按照Exercise的描述操作就可以了，得到<code>_alltraps</code>的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for _alltraps</span><br><span class="line"> */</span><br><span class="line">.global _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %ds</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>利用已经存在的<code>TRAPHANDLER</code>和<code>TRAPHANDLER_NOEC</code>宏可以来生成handler的入口，只需要区分有没有错误码就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">	TRAPHANDLER_NOEC(handler_divide, T_DIVIDE)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_debug, T_DEBUG)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_nmi, T_NMI)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_brkpt, T_BRKPT)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_oflow, T_OFLOW)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_bound, T_BOUND)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_illop, T_ILLOP)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_device, T_DEVICE)</span><br><span class="line">	TRAPHANDLER(handler_dblflt, T_DBLFLT)</span><br><span class="line">	TRAPHANDLER(handler_tss, T_TSS)</span><br><span class="line">	TRAPHANDLER(handler_segnp, T_SEGNP)</span><br><span class="line">	TRAPHANDLER(handler_stack, T_STACK)</span><br><span class="line">	TRAPHANDLER(handler_gpflt, T_GPFLT)</span><br><span class="line">	TRAPHANDLER(handler_pgflt, T_PGFLT)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_fperr, T_FPERR)</span><br><span class="line">	TRAPHANDLER(handler_align, T_ALIGN)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_mchk, T_MCHK)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_simderr, T_SIMDERR)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_syscall, T_SYSCALL)</span><br><span class="line">	TRAPHANDLER_NOEC(handler_default, T_DEFAULT)</span><br></pre></td></tr></table></figure>
<p>通过查询80386手册的9.10可以看到如下关于error code的总结：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Description                       Interrupt     Error Code</span><br><span class="line">Number</span><br><span class="line"></span><br><span class="line">Divide error                       0            No</span><br><span class="line">Debug exceptions                   1            No</span><br><span class="line">Breakpoint                         3            No</span><br><span class="line">Overflow                           4            No</span><br><span class="line">Bounds check                       5            No</span><br><span class="line">Invalid opcode                     6            No</span><br><span class="line">Coprocessor not available          7            No</span><br><span class="line">System error                       8            Yes (always 0)</span><br><span class="line">Coprocessor Segment Overrun        9            No</span><br><span class="line">Invalid TSS                       10            Yes</span><br><span class="line">Segment not present               11            Yes</span><br><span class="line">Stack exception                   12            Yes</span><br><span class="line">General protection fault          13            Yes</span><br><span class="line">Page fault                        14            Yes</span><br><span class="line">Coprocessor error                 16            No</span><br><span class="line">Two-byte SW interrupt             0-255         No</span><br></pre></td></tr></table></figure>
<p>在inc/mmu.h当中可以看到有关SETGATE的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Set up a normal interrupt/trap gate descriptor.</span><br><span class="line">// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.</span><br><span class="line">    //   see section 9.6.1.3 of the i386 reference: &quot;The difference between</span><br><span class="line">    //   an interrupt gate and a trap gate is in the effect on IF (the</span><br><span class="line">    //   interrupt-enable flag). An interrupt that vectors through an</span><br><span class="line">    //   interrupt gate resets IF, thereby preventing other interrupts from</span><br><span class="line">    //   interfering with the current interrupt handler. A subsequent IRET</span><br><span class="line">    //   instruction restores IF to the value in the EFLAGS image on the</span><br><span class="line">    //   stack. An interrupt through a trap gate does not change IF.&quot;</span><br><span class="line">// - sel: Code segment selector for interrupt/trap handler</span><br><span class="line">// - off: Offset in code segment for interrupt/trap handler</span><br><span class="line">// - dpl: Descriptor Privilege Level -</span><br><span class="line">//	  the privilege level required for software to invoke</span><br><span class="line">//	  this interrupt/trap gate explicitly using an int instruction.</span><br><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)			\</span><br><span class="line">&#123;								\</span><br><span class="line">	(gate).gd_off_15_0 = (uint32_t) (off) &amp; 0xffff;		\</span><br><span class="line">	(gate).gd_sel = (sel);					\</span><br><span class="line">	(gate).gd_args = 0;					\</span><br><span class="line">	(gate).gd_rsv1 = 0;					\</span><br><span class="line">	(gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;	\</span><br><span class="line">	(gate).gd_s = 0;					\</span><br><span class="line">	(gate).gd_dpl = (dpl);					\</span><br><span class="line">	(gate).gd_p = 1;					\</span><br><span class="line">	(gate).gd_off_31_16 = (uint32_t) (off) &gt;&gt; 16;		\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后再<code>trap_init()</code>当中进行这样的填充，要注意到断点和系统调用的dpl需要设置为3（用户）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// LAB 3: Your code here.</span><br><span class="line">	void handler_divide();</span><br><span class="line">	SETGATE(idt[T_DIVIDE], 0, GD_KT, handler_divide, 0);</span><br><span class="line">	void handler_debug();</span><br><span class="line">	SETGATE(idt[T_DEBUG], 0, GD_KT, handler_debug, 0);</span><br><span class="line">	void handler_nmi();</span><br><span class="line">	SETGATE(idt[T_NMI], 0, GD_KT, handler_nmi, 0);</span><br><span class="line">	void handler_brkpt();</span><br><span class="line">	SETGATE(idt[T_BRKPT], 0, GD_KT, handler_brkpt, 3);</span><br><span class="line">	void handler_oflow();</span><br><span class="line">	SETGATE(idt[T_OFLOW], 0, GD_KT, handler_oflow, 0);</span><br><span class="line">	void handler_bound();</span><br><span class="line">	SETGATE(idt[T_BOUND], 0, GD_KT, handler_bound, 0);</span><br><span class="line">	void handler_illop();</span><br><span class="line">	SETGATE(idt[T_ILLOP], 0, GD_KT, handler_illop, 0);</span><br><span class="line">	void handler_device();</span><br><span class="line">	SETGATE(idt[T_DEVICE], 0, GD_KT, handler_device, 0);</span><br><span class="line">	void handler_dblflt();</span><br><span class="line">	SETGATE(idt[T_DBLFLT], 0, GD_KT, handler_dblflt, 0);</span><br><span class="line">	void handler_tss();</span><br><span class="line">	SETGATE(idt[T_TSS], 0, GD_KT, handler_tss, 0);</span><br><span class="line">	void handler_segnp();</span><br><span class="line">	SETGATE(idt[T_SEGNP], 0, GD_KT, handler_segnp, 0);</span><br><span class="line">	void handler_stack();</span><br><span class="line">	SETGATE(idt[T_STACK], 0, GD_KT, handler_stack, 0);</span><br><span class="line">	void handler_gpflt();</span><br><span class="line">	SETGATE(idt[T_GPFLT], 0, GD_KT, handler_gpflt, 0);</span><br><span class="line">	void handler_pgflt();</span><br><span class="line">	SETGATE(idt[T_PGFLT], 0, GD_KT, handler_pgflt, 0);</span><br><span class="line">	void handler_fperr();</span><br><span class="line">	SETGATE(idt[T_FPERR], 0, GD_KT, handler_fperr, 0);</span><br><span class="line">	void handler_align();</span><br><span class="line">	SETGATE(idt[T_ALIGN], 0, GD_KT, handler_align, 0);</span><br><span class="line">	void handler_mchk();</span><br><span class="line">	SETGATE(idt[T_MCHK], 0, GD_KT, handler_mchk, 0);</span><br><span class="line">	void handler_simderr();</span><br><span class="line">	SETGATE(idt[T_SIMDERR], 0, GD_KT, handler_simderr, 0);</span><br><span class="line">	void handler_syscall();</span><br><span class="line">	SETGATE(idt[T_SYSCALL], 1, GD_KT, handler_syscall, 3);</span><br><span class="line">	void handler_default();</span><br><span class="line">	SETGATE(idt[T_DEFAULT], 0, GD_KT, handler_default, 0);</span><br></pre></td></tr></table></figure>
<p>利用<code>make grade</code>可以得到下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">divzero: OK (1.8s)</span><br><span class="line">    (Old jos.out.divzero failure log removed)</span><br><span class="line">softint: OK (1.7s)</span><br><span class="line">    (Old jos.out.softint failure log removed)</span><br><span class="line">badsegment: OK (2.1s)</span><br><span class="line">    (Old jos.out.badsegment failure log removed)</span><br><span class="line">Part A score: 30/30</span><br></pre></td></tr></table></figure>
<p>说明这里Part A的实现没有问题。</p>
<h2 id="question"><a class="markdownIt-Anchor" href="#question"></a> Question</h2>
<ol>
<li>
<p>如果所有的exception/interrupt都通过同样一个handler，那么就没有办法知道是通过哪一个中断进来的，不能设置对应的中断号，后面不能进行分发。</p>
</li>
<li>
<p>除了系统调用门，其他的特权级都设置成0，这里int $14本来应当触发page fault，但是这个时候权限不对，所以会触发general protection fault。如果允许他能够触发page fault的话，那么者会造成安全隐患。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">TRAP frame at 0xf0226000</span><br><span class="line">  edi  0x00000000</span><br><span class="line">  esi  0x00000000</span><br><span class="line">  ebp  0xeebfdfd0</span><br><span class="line">  oesp 0xefffffdc</span><br><span class="line">  ebx  0x00000000</span><br><span class="line">  edx  0x00000000</span><br><span class="line">  ecx  0x00000000</span><br><span class="line">  eax  0x00000000</span><br><span class="line">  es   0x----0023</span><br><span class="line">  ds   0x----0023</span><br><span class="line">  trap 0x0000000d General Protection</span><br><span class="line">  err  0x00000072</span><br><span class="line">  eip  0x00800037</span><br><span class="line">  cs   0x----001b</span><br><span class="line">  flag 0x00000046</span><br><span class="line">  esp  0xeebfdfd0</span><br><span class="line">  ss   0x----0023</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>当允许触发page fault的时候，可以看到保存的内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffc0</span><br><span class="line">TRAP frame at 0xefffffc0</span><br><span class="line">  edi  0x00000000</span><br><span class="line">  esi  0x00000000</span><br><span class="line">  ebp  0xeebfdfd0</span><br><span class="line">  oesp 0xefffffe0</span><br><span class="line">  ebx  0x00000000</span><br><span class="line">  edx  0x00000000</span><br><span class="line">  ecx  0x00000000</span><br><span class="line">  eax  0x00000000</span><br><span class="line">  es   0x----0023</span><br><span class="line">  ds   0x----0023</span><br><span class="line">  trap 0x0000000e Page Fault</span><br><span class="line">  cr2  0x00000000</span><br><span class="line">  err  0x00800039 [kernel, read, protection]</span><br><span class="line">  eip  0x0000001b</span><br><span class="line">  cs   0x----0046</span><br><span class="line">  flag 0xeebfdfd0</span><br><span class="line">  esp  0x00000023</span><br><span class="line">  ss   0x----ff53</span><br><span class="line">[00001000] free env 00001000</span><br></pre></td></tr></table></figure>
<p>在这里我的想法是第15行往后全部进行了一位的上移，可以看到之后的err当中的内容实际上应该是eip，eip的内容实际上是cs，以此类推。应该是cr2或者err code没有进行压入导致的。</p>
</li>
</ol>
<h2 id="exercise-5"><a class="markdownIt-Anchor" href="#exercise-5"></a> Exercise 5</h2>
<p>只需要在<code>trap_dispatch()</code>当中添加一个分支即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == T_PGFLT)</span><br><span class="line">&#123;</span><br><span class="line">	page_fault_handler(tf);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-6"><a class="markdownIt-Anchor" href="#exercise-6"></a> Exercise 6</h2>
<p>和Exercise 5相同，只需要在<code>trap_dispatch()</code>里面添加一个分支：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == T_BRKPT)</span><br><span class="line">&#123;</span><br><span class="line">	monitor(tf);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="question-2"><a class="markdownIt-Anchor" href="#question-2"></a> Question</h2>
<ol start="3">
<li>
<p>在于前面Exercise 4中的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETGATE(idt[T_BRKPT], 0, GD_KT, handler_brkpt, 3);</span><br></pre></td></tr></table></figure>
<p>这里当最后的dpl设置为3的时候，会正确的触发为break point exception，当设置为0的时候，会触发为general protection fault。其原因在于，如果设置为0，会导致断点触发需要内核级的权限，因为权限不够从而触发GPF。</p>
</li>
<li>
<p>这个测试的目的主要是检查权限是否设置正确，需要正确的区分用户和内核，防止用户对于内核代码进行操作产生安全隐患。</p>
</li>
</ol>
<h2 id="exercise-7"><a class="markdownIt-Anchor" href="#exercise-7"></a> Exercise 7</h2>
<p>在kern/trap.c里面，同之前两个Exercise一样进行分发的设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == T_SYSCALL)</span><br><span class="line">&#123;</span><br><span class="line">	tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax,</span><br><span class="line">	tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx, tf-&gt;tf_regs.reg_ebx,</span><br><span class="line">	tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在kern/syscall.c当中，利用switch进行分发即可，注意不同系统调用的参数就可以了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatches to the correct kernel function, passing the arguments.</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">uint32_t</span> syscallno, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4, <span class="type">uint32_t</span> a5)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line">	<span class="comment">// Return any appropriate return value.</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="type">const</span> <span class="type">char</span> *)a1, (<span class="type">size_t</span>)a2);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			<span class="keyword">return</span> sys_cgetc();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			<span class="keyword">return</span> sys_getenvid();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			<span class="keyword">return</span> sys_env_destroy((<span class="type">envid_t</span>)a1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NSYSCALLS:</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-8"><a class="markdownIt-Anchor" href="#exercise-8"></a> Exercise 8</h2>
<p>在lib/libmain.c当中，进行env_id的指定：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="type">envid_t</span> envid = sys_getenvid();</span><br><span class="line">	thisenv = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line">	<span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">		binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call user main routine</span></span><br><span class="line">	umain(argc, argv);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// exit gracefully</span></span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-9"><a class="markdownIt-Anchor" href="#exercise-9"></a> Exercise 9</h2>
<p>在kern/trap.c当中的<code>page_fault_handler()</code>函数当中，利用tf_cs来判断是不是在kernel-mode，如果是直接触发一个panic：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(((tf-&gt;tf_cs)&amp;<span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">	panic(<span class="string">&quot;page fault: happen in kernel mode! %08x\n&quot;</span>, tf-&gt;tf_cs);</span><br></pre></td></tr></table></figure>
<p>在kern/pmap.c当中，采用一个for循环对虚拟地址区间进行权限的检查，具体内容遵循注释就可以。当检查没有问题的时候返回值为0，否则返回值为-E_FAULT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Check that an environment is allowed to access the range of memory</span></span><br><span class="line"><span class="comment">// [va, va+len) with permissions &#x27;perm | PTE_P&#x27;.</span></span><br><span class="line"><span class="comment">// Normally &#x27;perm&#x27; will contain PTE_U at least, but this is not required.</span></span><br><span class="line"><span class="comment">// &#x27;va&#x27; and &#x27;len&#x27; need not be page-aligned; you must test every page that</span></span><br><span class="line"><span class="comment">// contains any of that range.  You will test either &#x27;len/PGSIZE&#x27;,</span></span><br><span class="line"><span class="comment">// &#x27;len/PGSIZE + 1&#x27;, or &#x27;len/PGSIZE + 2&#x27; pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A user program can access a virtual address if (1) the address is below</span></span><br><span class="line"><span class="comment">// ULIM, and (2) the page table gives it permission.  These are exactly</span></span><br><span class="line"><span class="comment">// the tests you should implement here.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there is an error, set the &#x27;user_mem_check_addr&#x27; variable to the first</span></span><br><span class="line"><span class="comment">// erroneous virtual address.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 if the user program can access this range of addresses,</span></span><br><span class="line"><span class="comment">// and -E_FAULT otherwise.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">user_mem_check</span><span class="params">(<span class="keyword">struct</span> Env *env, <span class="type">const</span> <span class="type">void</span> *va, <span class="type">size_t</span> len, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="type">int</span> newperm = perm | PTE_P;</span><br><span class="line">	<span class="type">uint32_t</span> cur_addr;</span><br><span class="line">	<span class="type">pte_t</span> * pte;</span><br><span class="line">	<span class="keyword">for</span>(cur_addr = (<span class="type">uint32_t</span>)va; cur_addr &lt; (<span class="type">uint32_t</span>)(va + len); cur_addr = ROUNDDOWN((cur_addr+PGSIZE),PGSIZE))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cur_addr &gt;= ULIM)</span><br><span class="line">		&#123;</span><br><span class="line">			user_mem_check_addr = cur_addr;</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">		pte = pgdir_walk(env-&gt;env_pgdir, (<span class="type">void</span> *)cur_addr, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span>((!pte) || ((*pte) &amp; newperm) != newperm)&#123;</span><br><span class="line">			user_mem_check_addr = cur_addr;</span><br><span class="line">			<span class="keyword">return</span> -E_FAULT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是要在kern/syscall.c当中需要填充上有关检查的部分！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print a string to the system console.</span></span><br><span class="line"><span class="comment">// The string is exactly &#x27;len&#x27; characters long.</span></span><br><span class="line"><span class="comment">// Destroys the environment on memory errors.</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">sys_cputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line">	<span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	user_mem_assert(curenv, s, len, PTE_W);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">	cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这里没有进行<code>user_mem_assert()</code>的话，执行buggyhello会进入系统调用然后在内核态触发page fault。</p>
<p>之后为backtrace相关的内容，在kern/kdebug.c当中添加有关usd，stabs，stabstr的检查如下，这里注意<code>user_mem_check()</code>当正常的时候返回值为0：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// The user-application linker script, user/user.ld,</span></span><br><span class="line">		<span class="comment">// puts information about the application&#x27;s stabs (equivalent</span></span><br><span class="line">		<span class="comment">// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and</span></span><br><span class="line">		<span class="comment">// __STABSTR_END__) in a structure located at virtual address</span></span><br><span class="line">		<span class="comment">// USTABDATA.</span></span><br><span class="line">		<span class="type">const</span> <span class="keyword">struct</span> UserStabData *usd = (<span class="type">const</span> <span class="keyword">struct</span> UserStabData *) USTABDATA;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure this memory is valid.</span></span><br><span class="line">		<span class="comment">// Return -1 if it is not.  Hint: Call user_mem_check.</span></span><br><span class="line">		<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, (<span class="type">void</span> *)usd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UserStabData), PTE_U))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">		stabs = usd-&gt;stabs;</span><br><span class="line">		stab_end = usd-&gt;stab_end;</span><br><span class="line">		stabstr = usd-&gt;stabstr;</span><br><span class="line">		stabstr_end = usd-&gt;stabstr_end;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure the STABS and string table memory is valid.</span></span><br><span class="line">		<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, (<span class="type">void</span> *)stabs, (<span class="type">uint32_t</span>)stabs-(<span class="type">uint32_t</span>)stab_end, PTE_U))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(user_mem_check(curenv, (<span class="type">void</span> *)stabstr, (<span class="type">uint32_t</span>)stabstr_end-(<span class="type">uint32_t</span>)stabstr, PTE_U))</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在执行breakpoint之后，利用backtrace得到的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">K&gt; backtrace</span><br><span class="line">Stack backtrace:</span><br><span class="line">ebp efffff10 eip f01010d6 args 00000001 efffff28 f0228000 00000000 f01e6a40</span><br><span class="line">	     kern/monitor.c:448: monitor+260</span><br><span class="line">ebp efffff80 eip f01048ca args f0228000 efffffbc 00000000 00000000 00000000</span><br><span class="line">	     kern/trap.c:195: trap+180</span><br><span class="line">ebp efffffb0 eip f0104a43 args efffffbc 00000000 00000000 eebfdfd0 efffffdc</span><br><span class="line">	     kern/trapentry.S:85: &lt;unknown&gt;+0</span><br><span class="line">ebp eebfdfd0 eip 0080007b args 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">	     lib/libmain.c:27: libmain+63</span><br><span class="line">ebp eebfdff0 eip 00800031 args 00000000 00000000Incoming TRAP frame at 0xeffffec</span><br><span class="line">kernel panic at kern/trap.c:270: page fault: happen in kernel mode! 00000008</span><br></pre></td></tr></table></figure>
<p>可以看到最后为lib/libmain.c，并且最终在内核态发生了page fault。可以发现，这个地方args在输出到第三个参数的时候突然触发，那应该是从ebp向上读取args触发的page fault。</p>
<p>结合<code>mom_backtrace()</code>的实现如下，应该是在13行的语句处出现的错误：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_backtrace</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">	<span class="type">uint32_t</span>* ebp = (<span class="type">uint32_t</span>*)read_ebp();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line">	<span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;ebp %08x &quot;</span>,ebp);</span><br><span class="line">		cprintf(<span class="string">&quot;eip %08x &quot;</span>,ebp[<span class="number">1</span>]);</span><br><span class="line">		cprintf(<span class="string">&quot;args&quot;</span>);</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="number">6</span>;++i)</span><br><span class="line">			cprintf(<span class="string">&quot; %08x&quot;</span>,ebp[i]);</span><br><span class="line">		cprintf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="exercise-10"><a class="markdownIt-Anchor" href="#exercise-10"></a> Exercise 10</h2>
<p>运行evilhello可以看到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001000] user_mem_check assertion failure for va f010000c</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br></pre></td></tr></table></figure>
<p>用户环境被销毁了，并且kernel没有panic，说明行为符合预期。</p>
<p>使用make grade命令可以得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">divzero: OK (1.4s)</span><br><span class="line">softint: OK (1.4s)</span><br><span class="line">badsegment: OK (2.0s)</span><br><span class="line">Part A score: 30/30</span><br><span class="line"></span><br><span class="line">faultread: OK (1.9s)</span><br><span class="line">faultreadkernel: OK (1.6s)</span><br><span class="line">faultwrite: OK (0.9s)</span><br><span class="line">faultwritekernel: OK (1.6s)</span><br><span class="line">breakpoint: OK (2.0s)</span><br><span class="line">testbss: OK (2.1s)</span><br><span class="line">hello: OK (1.8s)</span><br><span class="line">buggyhello: OK (1.7s)</span><br><span class="line">buggyhello2: OK (0.8s)</span><br><span class="line">evilhello: OK (1.6s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line"></span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure>
<p>说明lab3的内容已经被完成了。</p>
<h2 id="challenge-1"><a class="markdownIt-Anchor" href="#challenge-1"></a> Challenge 1</h2>
<p>参考了github上<a target="_blank" rel="noopener" href="https://github.com/SimpCosm/6.828/tree/master/lab3%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/SimpCosm/6.828/tree/master/lab3的实现。</a></p>
<p>其中TRAPHANDLER和TRAPHANDLER_NOEC的主要区别就在于有没有压入error code，这里采用一个if语句来进行判断：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define GENERALHANDLER(name, num)	\</span><br><span class="line">  .data;  \</span><br><span class="line">    .long name; \</span><br><span class="line">  .text;  \</span><br><span class="line">    .globl name;	\</span><br><span class="line">   	.type name, @function;	\</span><br><span class="line">   	.align 2;		\</span><br><span class="line">	name:	\</span><br><span class="line">    .if !(num == 8 || (num &gt;= 10 &amp;&amp; num &lt;= 14) || num == 17 );   \</span><br><span class="line">    pushl $0;   \</span><br><span class="line">   	.endif;     \</span><br><span class="line"> 		pushl $(num);							\</span><br><span class="line">  	jmp _alltraps</span><br></pre></td></tr></table></figure>
<p>之后构建一个数组vectors用来保存相关函数，就可以采用脚本语言批量生成重复代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">	.globl vectors</span><br><span class="line">vectors:</span><br><span class="line">		GENERALHANDLER(handler0, 0)</span><br><span class="line">    GENERALHANDLER(handler1, 1)</span><br><span class="line">    GENERALHANDLER(handler2, 2)</span><br><span class="line">    GENERALHANDLER(handler3, 3)</span><br><span class="line">    GENERALHANDLER(handler4, 4)</span><br><span class="line">    GENERALHANDLER(handler5, 5)</span><br><span class="line">    GENERALHANDLER(handler6, 6)</span><br><span class="line">    GENERALHANDLER(handler7, 7)</span><br><span class="line">    GENERALHANDLER(handler8, 8)</span><br><span class="line">    GENERALHANDLER(handler9, 9)</span><br><span class="line">    GENERALHANDLER(handler10, 10)</span><br><span class="line">    GENERALHANDLER(handler11, 11)</span><br><span class="line">    GENERALHANDLER(handler12, 12)</span><br><span class="line">    GENERALHANDLER(handler13, 13)</span><br><span class="line">    GENERALHANDLER(handler14, 14)</span><br><span class="line">    GENERALHANDLER(handler15, 15)</span><br><span class="line">    GENERALHANDLER(handler16, 16)</span><br><span class="line">    GENERALHANDLER(handler17, 17)</span><br><span class="line">    GENERALHANDLER(handler18, 18)</span><br><span class="line">    GENERALHANDLER(handler19, 19)</span><br><span class="line">    GENERALHANDLER(handler20, 20)</span><br><span class="line">    GENERALHANDLER(handler21, 21)</span><br><span class="line">    GENERALHANDLER(handler22, 22)</span><br><span class="line">    GENERALHANDLER(handler23, 23)</span><br><span class="line">    GENERALHANDLER(handler24, 24)</span><br><span class="line">    GENERALHANDLER(handler25, 25)</span><br><span class="line">    GENERALHANDLER(handler26, 26)</span><br><span class="line">    GENERALHANDLER(handler27, 27)</span><br><span class="line">    GENERALHANDLER(handler28, 28)</span><br><span class="line">    GENERALHANDLER(handler29, 29)</span><br><span class="line">    GENERALHANDLER(handler30, 30)</span><br><span class="line">    GENERALHANDLER(handler31, 31)</span><br><span class="line">    GENERALHANDLER(handler32, 32)</span><br><span class="line">    GENERALHANDLER(handler33, 33)</span><br><span class="line">    GENERALHANDLER(handler34, 34)</span><br><span class="line">    GENERALHANDLER(handler35, 35)</span><br><span class="line">    GENERALHANDLER(handler36, 36)</span><br><span class="line">    GENERALHANDLER(handler37, 37)</span><br><span class="line">    GENERALHANDLER(handler38, 38)</span><br><span class="line">    GENERALHANDLER(handler39, 39)</span><br><span class="line">    GENERALHANDLER(handler40, 40)</span><br><span class="line">    GENERALHANDLER(handler41, 41)</span><br><span class="line">    GENERALHANDLER(handler42, 42)</span><br><span class="line">    GENERALHANDLER(handler43, 43)</span><br><span class="line">    GENERALHANDLER(handler44, 44)</span><br><span class="line">    GENERALHANDLER(handler45, 45)</span><br><span class="line">    GENERALHANDLER(handler46, 46)</span><br><span class="line">    GENERALHANDLER(handler47, 47)</span><br><span class="line">    GENERALHANDLER(handler48, 48)</span><br><span class="line">    GENERALHANDLER(handler49, 49)</span><br><span class="line">    GENERALHANDLER(handler50, 50)</span><br><span class="line">    GENERALHANDLER(handler51, 51)</span><br><span class="line">    GENERALHANDLER(handler52, 52)</span><br><span class="line">    GENERALHANDLER(handler53, 53)</span><br></pre></td></tr></table></figure>
<p>之后就可以在kern/trap.c中对<code>trap_init()</code>采用循环构建入口，节省大量代码，对于特殊的可以单独提出来进行构造：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">54</span>; ++i)</span><br><span class="line">	SETGATE(idt[i], <span class="number">0</span>, GD_KT, vectors[i], <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, vectors[T_BRKPT], <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, vectors[T_SYSCALL], <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>在完成以上的修改之后，通过<code>make grade</code>仍然可以得到80分结果，说明没有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">divzero: OK (1.4s)</span><br><span class="line">softint: OK (1.4s)</span><br><span class="line">badsegment: OK (1.6s)</span><br><span class="line">Part A score: 30/30</span><br><span class="line"></span><br><span class="line">faultread: OK (0.9s)</span><br><span class="line">faultreadkernel: OK (1.5s)</span><br><span class="line">faultwrite: OK (2.0s)</span><br><span class="line">faultwritekernel: OK (1.6s)</span><br><span class="line">breakpoint: OK (0.9s)</span><br><span class="line">    (Old jos.out.breakpoint failure log removed)</span><br><span class="line">testbss: OK (1.5s)</span><br><span class="line">hello: OK (1.6s)</span><br><span class="line">buggyhello: OK (1.0s)</span><br><span class="line">buggyhello2: OK (1.4s)</span><br><span class="line">evilhello: OK (1.6s)</span><br><span class="line">Part B score: 50/50</span><br><span class="line"></span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure>
<h2 id="challenge-2"><a class="markdownIt-Anchor" href="#challenge-2"></a> Challenge 2</h2>
<p>Intel手册中12.3.1.4节为关于单步调试的相关内容：</p>
<blockquote>
<p>This debug condition occurs at the end of an instruction if the trap flag (TF) of the flags register held the value one at the beginning of that instruction. Note that the exception does not occur at the end of an instruction that sets TF. For example, if POPF is used to set TF, a single-step trap does not occur until after the instruction that follows POPF.</p>
</blockquote>
<p>意思就是设置了TF之后，执行完下一条命令会触发一个DEBUG。于是可以照如下写continue和stepi指令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_continue</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tf)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	tf-&gt;tf_eflags &amp;= ~FL_TF;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">mon_stepi</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!tf)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	tf-&gt;tf_eflags |= FL_TF;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意第六行，如果在continue里面不进行eflags维护单纯返回的话，会导致在执行了stepi指令之后，continue指令无效的情况。</p>
<p>同时为了使得stepi触发DEBUG之后能够回到monitor，需要在<code>trap_dispatch()</code>当中添加关于T_DEBUG的分发：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == T_BRKPT || tf-&gt;tf_trapno == T_DEBUG)</span><br><span class="line">&#123;</span><br><span class="line">	monitor(tf);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时利用continue可以在断点程序之后继续执行，效果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">TRAP frame at 0xf0228000</span><br><span class="line">  edi  0x00000000</span><br><span class="line">  esi  0x00000000</span><br><span class="line">  ebp  0xeebfdfd0</span><br><span class="line">  oesp 0xefffffdc</span><br><span class="line">  ebx  0x00000000</span><br><span class="line">  edx  0x00000000</span><br><span class="line">  ecx  0x00000000</span><br><span class="line">  eax  0xeec00000</span><br><span class="line">  es   0x----0023</span><br><span class="line">  ds   0x----0023</span><br><span class="line">  trap 0x00000003 Breakpoint</span><br><span class="line">  err  0x00000000</span><br><span class="line">  eip  0x00800038</span><br><span class="line">  cs   0x----001b</span><br><span class="line">  flag 0x00000046</span><br><span class="line">  esp  0xeebfdfd0</span><br><span class="line">  ss   0x----0023</span><br><span class="line">K&gt; continue</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br><span class="line">Welcome to the JOS kernel monitor!</span><br><span class="line">Type &#x27;help&#x27; for a list of commands.</span><br><span class="line">K&gt;</span><br></pre></td></tr></table></figure>
<h2 id="challenge-3"><a class="markdownIt-Anchor" href="#challenge-3"></a> Challenge 3</h2>
<p>从lab中所给的链接可以找到<code>rdmsr</code>和<code>wrmsr</code>的宏定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define rdmsr(msr,val1,val2) \</span><br><span class="line">	__asm__ __volatile__(&quot;rdmsr&quot; \</span><br><span class="line">	: &quot;=a&quot; (val1), &quot;=d&quot; (val2) \</span><br><span class="line">	: &quot;c&quot; (msr))</span><br><span class="line"></span><br><span class="line">#define wrmsr(msr,val1,val2) \</span><br><span class="line">	__asm__ __volatile__(&quot;wrmsr&quot; \</span><br><span class="line">	: /* no outputs */ \</span><br><span class="line">	: &quot;c&quot; (msr), &quot;a&quot; (val1), &quot;d&quot; (val2))</span><br></pre></td></tr></table></figure>
<p>从IA32的手册当中可以找到在使用SYSENTER之前所需要设置的相关内容：</p>
<blockquote>
<ul>
<li><strong>IA32_SYSENTER_CS</strong> (MSR address 174H) — The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level 0 stack segment (see the Operation section). This value cannot indicate a null selector.</li>
<li><strong>IA32_SYSENTER_EIP</strong> (MSR address 176H) — The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.</li>
<li><strong>IA32_SYSENTER_ESP</strong> (MSR address 175H) — The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.</li>
</ul>
</blockquote>
<p>添加一个<code>sysenter_init()</code>并且在<code>trap_init()</code>内进行调用来实现初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sysenter_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	wrmsr(<span class="number">0x174</span>, GD_KT, <span class="number">0</span>);</span><br><span class="line">	wrmsr(<span class="number">0x176</span>, syscall_fast, <span class="number">0</span>);</span><br><span class="line">	wrmsr(<span class="number">0x175</span>, KSTACKTOP, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在lib/syscall.c里面需要仿照syscall写一个syscall_fast，与syscall不同的是，这里采用sysenter而不是int 0x30。同时需要将%esi保存为sysenter之后的位置，并且push和pop保存%ebp。这里参数同syscall相似，只是少了最后一个a5。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span></span><br><span class="line"><span class="title function_">syscall_fast</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> check, <span class="type">uint32_t</span> a1, <span class="type">uint32_t</span> a2, <span class="type">uint32_t</span> a3, <span class="type">uint32_t</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> ret;</span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">			<span class="string">&quot;leal .after_sysenter_label, %%esi\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;push %%ebp\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;movl %%esp, %%ebp\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;sysenter\n&quot;</span></span></span><br><span class="line"><span class="params">			<span class="string">&quot;.after_sysenter_label: popl %%ebp\n&quot;</span></span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;=a&quot;</span> (ret)</span></span><br><span class="line"><span class="params">		     : <span class="string">&quot;a&quot;</span> (num),</span></span><br><span class="line"><span class="params">		       <span class="string">&quot;d&quot;</span> (a1),</span></span><br><span class="line"><span class="params">		       <span class="string">&quot;c&quot;</span> (a2),</span></span><br><span class="line"><span class="params">		       <span class="string">&quot;b&quot;</span> (a3),</span></span><br><span class="line"><span class="params">		       <span class="string">&quot;D&quot;</span> (a4)</span></span><br><span class="line"><span class="params">		     :)</span>;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(check &amp;&amp; ret &gt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;syscall %d returned %d (&gt; 0)&quot;</span>, num, ret);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在kern/syscall.c中要写一个handler用来处理对应的系统调用，这个就是之前在init里面所填充的入口，流程为从保存的寄存器中取得参数，执行相应的内容，结束之后将返回值保存并利用sysexit返回（这里如果参数不都采用&quot;=m&quot;的约束会出现bug，原因未知）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall_fast</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> syscallno, a1, a2, a3, a4, ret;</span><br><span class="line">	<span class="type">uint32_t</span> eip, esp;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%eax, %0\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%edx, %1\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%ecx, %2\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%ebx, %3\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%edi, %4\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov %%esi, %5\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;mov (%%ebp), %6\n&quot;</span></span></span><br><span class="line"><span class="params">		:<span class="string">&quot;=r&quot;</span> (syscallno),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=m&quot;</span> (a1),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=m&quot;</span> (a2),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=m&quot;</span> (a3),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=m&quot;</span> (a4),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=r&quot;</span> (eip),</span></span><br><span class="line"><span class="params">		 <span class="string">&quot;=r&quot;</span> (esp)</span></span><br><span class="line"><span class="params">	)</span>;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line">		<span class="keyword">case</span> SYS_cputs:</span><br><span class="line">			sys_cputs((<span class="type">const</span> <span class="type">char</span> *)a1, (<span class="type">size_t</span>)a2);</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_cgetc:</span><br><span class="line">			ret = sys_cgetc();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_getenvid:</span><br><span class="line">			ret = sys_getenvid();</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SYS_env_destroy:</span><br><span class="line">			ret = sys_env_destroy((<span class="type">envid_t</span>)a1);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> NSYSCALLS:</span><br><span class="line">			ret = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			panic(<span class="string">&quot;syscall_fast: wrong syscallno\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;sysexit\n&quot;</span></span></span><br><span class="line"><span class="params">			:</span></span><br><span class="line"><span class="params">			: <span class="string">&quot;a&quot;</span> (ret),</span></span><br><span class="line"><span class="params">			  <span class="string">&quot;d&quot;</span> (eip),</span></span><br><span class="line"><span class="params">			  <span class="string">&quot;c&quot;</span> (esp)</span></span><br><span class="line"><span class="params">			:)</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在lib/syscall.c中修改<code>sys_cputs()</code>让其调用<code>syscall_fast()</code>进行测试（实际上就是丢掉最后一个传入的参数就可以了）：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sys_cputs</span>(<span class="params"><span class="keyword">const</span> <span class="built_in">char</span> *s, size_t len</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	syscall_fast(SYS_cputs, <span class="number">0</span>, (uint32_t)s, len, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行hello能够得到的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[00000000] new env 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">hello, world</span><br><span class="line">i am environment 00001000</span><br><span class="line">Incoming TRAP frame at 0xefffffbc</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">Destroyed the only environment - nothing more to do!</span><br></pre></td></tr></table></figure>
<p>对比原来的输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">00000000</span>] new env <span class="number">00001000</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line">hello, world</span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line">i am environment <span class="number">00001000</span></span><br><span class="line">Incoming TRAP frame at <span class="number">0xefffffbc</span></span><br><span class="line">[<span class="number">00001000</span>] exiting gracefully</span><br><span class="line">[<span class="number">00001000</span>] <span class="built_in">free</span> env <span class="number">00001000</span></span><br><span class="line">Destroyed the only environment - nothing more to <span class="keyword">do</span>!</span><br></pre></td></tr></table></figure>
<p>可以发现由于在进行系统调用的时候没有采用<code>int 0x30</code>，所以这里在每次输出前并没有都进入<code>trap()</code>函数，使得少去了两行<code>Incoming TRAP frame at ....</code>的输出。</p>
<p>替换后使用<code>make grade</code>也能够得到满分80分，至少在这个lab中采用sysenter不会有问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-828/" rel="tag"># 6.828</a>
              <a href="/tags/Operating-System/" rel="tag"># Operating System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/30/6828-lab2/" rel="prev" title="MIT6.828 Lab2">
      <i class="fa fa-chevron-left"></i> MIT6.828 Lab2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/04/24/CF-1341E/" rel="next" title="Codeforces 1341E - Nastya and Unexpected Guest">
      Codeforces 1341E - Nastya and Unexpected Guest <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-1"><span class="nav-number">1.</span> <span class="nav-text"> Exercise 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exericse-2"><span class="nav-number">2.</span> <span class="nav-text"> Exericse 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#env_init"><span class="nav-number">2.1.</span> <span class="nav-text"> env_init()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env_setup_vm"><span class="nav-number">2.2.</span> <span class="nav-text"> env_setup_vm()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#region_alloc"><span class="nav-number">2.3.</span> <span class="nav-text"> region_alloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load_icode"><span class="nav-number">2.4.</span> <span class="nav-text"> load_icode()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env_create"><span class="nav-number">2.5.</span> <span class="nav-text"> env_create()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#env_run"><span class="nav-number">2.6.</span> <span class="nav-text"> env_run()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gdb%E5%AF%B9hello%E8%BF%9B%E8%A1%8C%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95"><span class="nav-number">2.7.</span> <span class="nav-text"> gdb对hello进行断点调试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-3"><span class="nav-number">3.</span> <span class="nav-text"> Exercise 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-4"><span class="nav-number">4.</span> <span class="nav-text"> Exercise 4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question"><span class="nav-number">5.</span> <span class="nav-text"> Question</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-5"><span class="nav-number">6.</span> <span class="nav-text"> Exercise 5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-6"><span class="nav-number">7.</span> <span class="nav-text"> Exercise 6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question-2"><span class="nav-number">8.</span> <span class="nav-text"> Question</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-7"><span class="nav-number">9.</span> <span class="nav-text"> Exercise 7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-8"><span class="nav-number">10.</span> <span class="nav-text"> Exercise 8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-9"><span class="nav-number">11.</span> <span class="nav-text"> Exercise 9</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-10"><span class="nav-number">12.</span> <span class="nav-text"> Exercise 10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge-1"><span class="nav-number">13.</span> <span class="nav-text"> Challenge 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge-2"><span class="nav-number">14.</span> <span class="nav-text"> Challenge 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge-3"><span class="nav-number">15.</span> <span class="nav-text"> Challenge 3</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pims</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pims</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
