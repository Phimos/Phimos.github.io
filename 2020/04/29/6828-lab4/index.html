<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://phimos.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Exercise 1 这个建立映射的函数实际上和kern&#x2F;pmap.c当中的boot_alloc()存在类似的地方，都是利用一个静态的变量来保存当前分配空间的起始地方，然后不断的增长进行分配。由于base每次都会增长，所以每次都是映射新的页面。 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.828 Lab4">
<meta property="og:url" content="http://phimos.github.io/2020/04/29/6828-lab4/index.html">
<meta property="og:site_name" content="Pims的博客">
<meta property="og:description" content="Exercise 1 这个建立映射的函数实际上和kern&#x2F;pmap.c当中的boot_alloc()存在类似的地方，都是利用一个静态的变量来保存当前分配空间的起始地方，然后不断的增长进行分配。由于base每次都会增长，所以每次都是映射新的页面。 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F;&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-29T09:45:48.000Z">
<meta property="article:modified_time" content="2020-04-29T09:45:48.000Z">
<meta property="article:author" content="Pims">
<meta property="article:tag" content="6.828">
<meta property="article:tag" content="Operating System">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://phimos.github.io/2020/04/29/6828-lab4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MIT6.828 Lab4 | Pims的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Pims的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pims的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://phimos.github.io/2020/04/29/6828-lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pims">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pims的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT6.828 Lab4
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-29 17:45:48" itemprop="dateCreated datePublished" datetime="2020-04-29T17:45:48+08:00">2020-04-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="exercise-1"><a class="markdownIt-Anchor" href="#exercise-1"></a> Exercise 1</h2>
<p>这个建立映射的函数实际上和kern/pmap.c当中的<code>boot_alloc()</code>存在类似的地方，都是利用一个静态的变量来保存当前分配空间的起始地方，然后不断的增长进行分配。由于base每次都会增长，所以每次都是映射新的页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Reserve size bytes in the MMIO region and map [pa,pa+size) at this</span></span><br><span class="line"><span class="comment">// location.  Return the base of the reserved region.  size does *not*</span></span><br><span class="line"><span class="comment">// have to be multiple of PGSIZE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">mmio_map_region</span><span class="params">(<span class="type">physaddr_t</span> pa, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">	<span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="type">uintptr_t</span> result;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line">	<span class="comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span></span><br><span class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line">	<span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span></span><br><span class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line">	<span class="comment">// 3A.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span></span><br><span class="line">	<span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	<span class="keyword">if</span>(base + ROUNDUP(size, PGSIZE) &gt;= MMIOLIM)</span><br><span class="line">		panic(<span class="string">&quot;mmio_map_region: out of memory\n&quot;</span>);</span><br><span class="line">	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);</span><br><span class="line">	result = base;</span><br><span class="line">	base += ROUNDUP(size, PGSIZE);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-2"><a class="markdownIt-Anchor" href="#exercise-2"></a> Exercise 2</h2>
<p>修改<code>page_init()</code>的内容如下，只是增加一个特殊处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1:</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line">pages[<span class="number">0</span>].pp_link = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">// case 2, 3, 4:</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; npages; i++) &#123;</span><br><span class="line">	<span class="keyword">if</span>((IOPHYSMEM &lt;= i * PGSIZE &amp;&amp; i * PGSIZE &lt; pa_free_start) || page2pa(pages + i) == MPENTRY_PADDR)</span><br><span class="line">	&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">		pages[i].pp_link = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要在第6行添加一个判断就可以了。</p>
<p>之后执行<code>make qemu</code>就可以看到如下的check都已经成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">check_page_free_list() succeeded!</span><br><span class="line">check_page_alloc() succeeded!</span><br><span class="line">check_page() succeeded!</span><br></pre></td></tr></table></figure>
<h2 id="question-1"><a class="markdownIt-Anchor" href="#question-1"></a> Question 1</h2>
<p>宏<code>MPBOOTPHYS</code>的作用是将高地址转换为低地址，使得可以在实模式下进行访问。在boot.S当中，本来就已经被链接到了低地址，不需要进行转换，而mpentry.S的代码都位于KERNBASE的上方，所以需要手动的利用<code>MPBOOTPHYS</code>宏进行转换。</p>
<h2 id="exercise-3"><a class="markdownIt-Anchor" href="#exercise-3"></a> Exercise 3</h2>
<p>这里直接利用一个循环进行映射，由于每个栈之间是存在一个Gap的，所以只有<code>[kstacktop_i - KSTKSIZE, kstacktop_i)</code>部分需要进行映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Modify mappings in kern_pgdir to support SMP</span></span><br><span class="line"><span class="comment">//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">mem_init_mp</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span></span><br><span class="line">	<span class="comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span></span><br><span class="line">	<span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line">	<span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line">	<span class="comment">// mem_init:</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line">	<span class="comment">//          -- backed by physical memory</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line">	<span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line">	<span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line">	<span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line">	<span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	<span class="type">uint32_t</span> i, kstacktop_i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>, kstacktop_i=KSTACKTOP;i &lt; NCPU; ++i, kstacktop_i -= KSTKSIZE + KSTKGAP)</span><br><span class="line">		boot_map_region(kern_pgdir, kstacktop_i - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-4"><a class="markdownIt-Anchor" href="#exercise-4"></a> Exercise 4</h2>
<p>这里实际上就是用thiscpu来替换原本的全局变量，使得本来是在lab3当中对于单CPU适用的情况可以适用于多个CPU的情形。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize and load the per-CPU TSS and IDT</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap_init_percpu</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line">	<span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line">	<span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line">	<span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span></span><br><span class="line">	<span class="comment">//     struct CpuInfo;</span></span><br><span class="line">	<span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line">	<span class="comment">//     thiscpu-&gt;cpu_id;</span></span><br><span class="line">	<span class="comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span></span><br><span class="line">	<span class="comment">//     rather than the global &quot;ts&quot; variable;</span></span><br><span class="line">	<span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span></span><br><span class="line">	<span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span></span><br><span class="line">	<span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line">	<span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span></span><br><span class="line">	<span class="comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span></span><br><span class="line">	<span class="comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span></span><br><span class="line">	<span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line">	<span class="comment">// user space on that CPU.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// when we trap to the kernel.</span></span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKSIZE + KSTKGAP);</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="type">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">					<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Taskstate) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>) + cpunum()].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">	ltr(GD_TSS0 + (cpunum() &lt;&lt; <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the IDT</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-5"><a class="markdownIt-Anchor" href="#exercise-5"></a> Exercise 5</h2>
<p>根据文档的描述在四个所需要插入大内核锁的地方进行<code>lock_kernel()</code>和<code>unlock_kernel()</code>的操作。</p>
<ul>
<li>
<p>In i386_init(), acquire the lock before the BSP wakes up the other CPUs.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the big kernel lock before waking up APs</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Starting non-boot CPUs</span></span><br><span class="line">boot_aps();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>In mp_main(), acquire the lock after initializing the AP, and then call sched_yield() to start running environments on this AP.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line"><span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line"><span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line">lock_kernel();</span><br><span class="line">sched_yield();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>In trap(), acquire the lock when trapped from user mode. To determine whether a trap happened in user mode or in kernel mode, check the low bits of the tf_cs.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trapped from user mode.</span></span><br><span class="line"><span class="comment">// Acquire the big kernel lock before doing any</span></span><br><span class="line"><span class="comment">// serious kernel work.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">lock_kernel();</span><br><span class="line">assert(curenv);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>In env_run(), release the lock right before switching to user mode. Do not do that too early or too late, otherwise you will experience races or deadlocks.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">unlock_kernel();</span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="question-2"><a class="markdownIt-Anchor" href="#question-2"></a> Question 2</h2>
<p>从trapentry.S当中可以看到，在调用<code>trap()</code>之前（还没有获得大内核锁），这个时候就已经往内核栈中压入了寄存器信息，如果内核栈不分离的话，在这个时候切换就会造成错误。</p>
<h2 id="exercise-6"><a class="markdownIt-Anchor" href="#exercise-6"></a> Exercise 6</h2>
<p>这里的调度方法实际上是一个非常暴力的轮询，如果找到了一个状态是<code>ENV_RUNNABLE</code>的进程那么就让他上CPU。如果找了一圈都没有找到合适的进程的话，就看起始进程，如果它本来就在当前CPU上运行的话，那么就继续运行，否则的话一个进程不能在两个CPU上同时运行，就调用<code>sched_halt()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose a user environment to run and run it.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line">	<span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">	<span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">	<span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line">	<span class="comment">// choose that environment.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line">	<span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">	<span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">	<span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> start_i, i;</span><br><span class="line">	<span class="keyword">if</span>(!curenv)</span><br><span class="line">		start_i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		start_i = curenv-&gt;env_id;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NENV; ++i)</span><br><span class="line">		<span class="keyword">if</span>(envs[(start_i + i)%NENV].env_status == ENV_RUNNABLE)</span><br><span class="line">			env_run(&amp;envs[(start_i + i)%NENV]);</span><br><span class="line">	<span class="keyword">if</span>(envs[start_i%NENV].env_status == ENV_RUNNING &amp;&amp; envs[start_i%NENV].env_cpunum == cpunum())</span><br><span class="line">		env_run(&amp;envs[start_i%NENV]);</span><br><span class="line">	<span class="comment">// sched_halt never returns</span></span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>syscall()</code>当中添加新的系统调用的分发：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_yield:</span><br><span class="line">	sys_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>mp_main()</code>当中调用<code>sched_yield()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup code for APs</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">mp_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// We are in high EIP now, safe to switch to kern_pgdir </span></span><br><span class="line">	lcr3(PADDR(kern_pgdir));</span><br><span class="line">	cprintf(<span class="string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());</span><br><span class="line"></span><br><span class="line">	lapic_init();</span><br><span class="line">	env_init_percpu();</span><br><span class="line">	trap_init_percpu();</span><br><span class="line">	xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="comment">// tell boot_aps() we&#x27;re up</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that we have finished some basic setup, call sched_yield()</span></span><br><span class="line">	<span class="comment">// to start running processes on this CPU.  But make sure that</span></span><br><span class="line">	<span class="comment">// only one CPU can enter the scheduler at a time!</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	lock_kernel();</span><br><span class="line">	sched_yield();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Remove this after you finish Exercise 6</span></span><br><span class="line">	<span class="keyword">for</span> (;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="question-3"><a class="markdownIt-Anchor" href="#question-3"></a> Question 3</h2>
<p>看<code>env_run()</code>当中对应代码部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</span><br><span class="line">	curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">curenv = e;</span><br><span class="line">e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">++(e-&gt;env_runs);</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line">unlock_kernel();</span><br><span class="line"></span><br><span class="line">env_pop_tf(&amp;(e-&gt;env_tf));</span><br></pre></td></tr></table></figure>
<p>在<code>lcr3()</code>前后都能够正常对<code>e</code>进行解引用是因为，在设置<code>env_pgdir</code>的时候是以<code>kern_pgdir</code>作为模板进行修改的，<code>e</code>地址在两个地址空间中是映射到同一个物理地址的，所以这里进行解引用的操作不会有问题。</p>
<h2 id="question-4"><a class="markdownIt-Anchor" href="#question-4"></a> Question 4</h2>
<p>保存寄存器信息的操作发生在kern/trapentry.S当中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.global _alltraps</span><br><span class="line">_alltraps:</span><br><span class="line">	pushl %ds</span><br><span class="line">	pushl %es</span><br><span class="line">	pushal</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %ds</span><br><span class="line">	pushl $GD_KD</span><br><span class="line">	popl %es</span><br><span class="line">	pushl %esp</span><br><span class="line">	call trap</span><br></pre></td></tr></table></figure>
<p>恢复寄存器的操作发生在kern/env.c的<code>env_pop_tf()</code>当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">env_pop_tf</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Record the CPU we are running on for user-space debugging</span></span><br><span class="line">	curenv-&gt;env_cpunum = cpunum();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tmovl %0,%%esp\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopal\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%es\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tpopl %%ds\n&quot;</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="comment">/* skip tf_trapno and tf_errcode */</span></span></span><br><span class="line"><span class="params">		<span class="string">&quot;\tiret\n&quot;</span></span></span><br><span class="line"><span class="params">		: : <span class="string">&quot;g&quot;</span> (tf) : <span class="string">&quot;memory&quot;</span>)</span>;</span><br><span class="line">	panic(<span class="string">&quot;iret failed&quot;</span>);  <span class="comment">/* mostly to placate the compiler */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-7"><a class="markdownIt-Anchor" href="#exercise-7"></a> Exercise 7</h2>
<p>这里每一个系统调用的主要内容都不复杂，主要的是进行许多参数有效性的检查，只需要按照注释中的内容进行参数检查就可以。</p>
<h3 id="sys_exofork"><a class="markdownIt-Anchor" href="#sys_exofork"></a> sys_exofork()</h3>
<p>传建一个子进程，在子进程中返回值为0，在父进程中返回的是子进程的id，先将子进程的状态设置成<code>ENV_NOT_RUNNABLE</code>之后再进行地址空间的复制之后可以会再设置成可运行的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a new environment.</span></span><br><span class="line"><span class="comment">// Returns envid of new environment, or &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_NO_FREE_ENV if no free environment is available.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM on memory exhaustion.</span></span><br><span class="line"><span class="type">static</span> <span class="type">envid_t</span></span><br><span class="line"><span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">	<span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">	<span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">	<span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">	<span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">e</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span>((ret = env_alloc(&amp;e, curenv-&gt;env_id)))</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	e-&gt;env_tf = curenv-&gt;env_tf;</span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys_env_set_status"><a class="markdownIt-Anchor" href="#sys_env_set_status"></a> sys_env_set_status()</h3>
<p>就是23行处的设置<code>env_status</code>。但是这个系统调用只能在<code>ENV_RUNNABLE</code>和<code>ENV_NOT_RUNNABLE</code>当中设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set envid&#x27;s env_status to status, which must be ENV_RUNNABLE</span></span><br><span class="line"><span class="comment">// or ENV_NOT_RUNNABLE.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if status is not a valid status for an environment.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_status</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span></span><br><span class="line">	<span class="comment">// envid to a struct Env.</span></span><br><span class="line">	<span class="comment">// You should set envid2env&#x27;s third argument to 1, which will</span></span><br><span class="line">	<span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">	<span class="comment">// envid&#x27;s status.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">if</span>(status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE)</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	env-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys_page_alloc"><a class="markdownIt-Anchor" href="#sys_page_alloc"></a> sys_page_alloc()</h3>
<p>在<code>envid</code>的地址空间中分配一个页面，除去类型检查之外所做的内容就是<code>page_alloc()</code>和<code>page_insert()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate a page of memory and map it at &#x27;va&#x27; with permission</span></span><br><span class="line"><span class="comment">// &#x27;perm&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// The page&#x27;s contents are set to 0.</span></span><br><span class="line"><span class="comment">// If a page is already mapped at &#x27;va&#x27;, that page is unmapped as a</span></span><br><span class="line"><span class="comment">// side effect.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// perm -- PTE_U | PTE_P must be set, PTE_AVAIL | PTE_W may or may not be set,</span></span><br><span class="line"><span class="comment">//         but no other bits may be set.  See PTE_SYSCALL in inc/mmu.h.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see above).</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there&#x27;s no memory to allocate the new page,</span></span><br><span class="line"><span class="comment">//		or to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_alloc</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">	<span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;	</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)va &gt;= UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">if</span>((perm &amp; (PTE_U | PTE_P)) != (PTE_U | PTE_P) || perm &amp; (~PTE_SYSCALL))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(!(pp = page_alloc(<span class="number">1</span>)))</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	<span class="keyword">if</span>(page_insert(env-&gt;env_pgdir, pp, va, perm))</span><br><span class="line">	&#123;</span><br><span class="line">		page_free(pp);</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys_page_map"><a class="markdownIt-Anchor" href="#sys_page_map"></a> sys_page_map()</h3>
<p>37行之前为参数的检查，39行之后为具体执行的内容，实际上完成的就是将<code>srcenvid</code>对应进程的地址空间中的<code>srcva</code>页面映射到<code>dstenvid</code>对应进程的地址空间中的<code>dstva</code>页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map the page of memory at &#x27;srcva&#x27; in srcenvid&#x27;s address space</span></span><br><span class="line"><span class="comment">// at &#x27;dstva&#x27; in dstenvid&#x27;s address space with permission &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment">// Perm has the same restrictions as in sys_page_alloc, except</span></span><br><span class="line"><span class="comment">// that it also must not grant write access to a read-only</span></span><br><span class="line"><span class="comment">// page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if srcenvid and/or dstenvid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change one of them.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &gt;= UTOP or srcva is not page-aligned,</span></span><br><span class="line"><span class="comment">//		or dstva &gt;= UTOP or dstva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL is srcva is not mapped in srcenvid&#x27;s address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if perm is inappropriate (see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in srcenvid&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there&#x27;s no memory to allocate any necessary page tables.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_map</span><span class="params">(<span class="type">envid_t</span> srcenvid, <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">	     <span class="type">envid_t</span> dstenvid, <span class="type">void</span> *dstva, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">	<span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>, *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(srcenvid, &amp;srcenv, <span class="number">1</span>) || envid2env(dstenvid, &amp;dstenv, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;	</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)srcva &gt;= UTOP || srcva != ROUNDDOWN(srcva, PGSIZE))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)dstva &gt;= UTOP || dstva != ROUNDDOWN(dstva, PGSIZE))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">if</span>((perm &amp; (PTE_U | PTE_P)) != (PTE_U | PTE_P) || perm &amp; (~PTE_SYSCALL))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> *pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(!(pp = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;pte)))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">if</span>((((*pte) &amp; PTE_W) == <span class="number">0</span>) &amp;&amp; (perm &amp; PTE_W))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sys_page_unmap"><a class="markdownIt-Anchor" href="#sys_page_unmap"></a> sys_page_unmap()</h3>
<p>实际上就是19行处的<code>page_remove()</code>操作，剩下的是参数的有效性检查。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unmap the page of memory at &#x27;va&#x27; in the address space of &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// If no page is mapped, the function silently succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Return 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if va &gt;= UTOP, or va is not page-aligned.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_page_unmap</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *va)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;	</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)va &gt;= UTOP || va != ROUNDDOWN(va, PGSIZE))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	page_remove(env-&gt;env_pgdir, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后要在<code>syscall()</code>当中添加分发的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SYS_exofork:</span><br><span class="line">	<span class="keyword">return</span> sys_exofork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYS_env_set_status:</span><br><span class="line">	<span class="keyword">return</span> sys_env_set_status((<span class="type">envid_t</span>)a1, (<span class="type">int</span>)a2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYS_page_alloc:</span><br><span class="line">	<span class="keyword">return</span> sys_page_alloc((<span class="type">envid_t</span>)a1, (<span class="type">void</span> *)a2, (<span class="type">int</span>) a3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYS_page_map:</span><br><span class="line">	<span class="keyword">return</span> sys_page_map((<span class="type">envid_t</span>)a1, (<span class="type">void</span> *)a2, (<span class="type">envid_t</span>)a3, (<span class="type">void</span> *)a4, (<span class="type">int</span>)a5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SYS_page_unmap:</span><br><span class="line">	<span class="keyword">return</span> sys_page_unmap((<span class="type">envid_t</span>)a1, (<span class="type">void</span> *)a2);</span><br></pre></td></tr></table></figure>
<h2 id="exercise-8"><a class="markdownIt-Anchor" href="#exercise-8"></a> Exercise 8</h2>
<p>又是一个系统调用的设置，当使用<code>envid2env()</code>的时候需要进行权限的检查，如果能够正常的得到env的话就设置对应的<code>env_pgfault_upcall</code>。同样要在<code>syscall()</code>当中添加新的case。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the page fault upcall for &#x27;envid&#x27; by modifying the corresponding struct</span></span><br><span class="line"><span class="comment">// Env&#x27;s &#x27;env_pgfault_upcall&#x27; field.  When &#x27;envid&#x27; causes a page fault, the</span></span><br><span class="line"><span class="comment">// kernel will push a fault record onto the exception stack, then branch to</span></span><br><span class="line"><span class="comment">// &#x27;func&#x27;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist,</span></span><br><span class="line"><span class="comment">//		or the caller doesn&#x27;t have permission to change envid.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_env_set_pgfault_upcall</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">void</span> *func)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;env, <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	env-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-9"><a class="markdownIt-Anchor" href="#exercise-9"></a> Exercise 9</h2>
<p>这里关于<code>page_fault_handler()</code>在有<code>env_pgfault_upcall</code>的情况下，分为两种情况，如果本身在Exception Stack里面的话，那么需要空出一个word的大小，具体的作用在后面Exercise 10会体现。否则的话直接将结构体压在Exception Stack的底部就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> * <span class="title">utf</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(ROUNDDOWN(tf-&gt;tf_esp, PGSIZE) == UXSTACKTOP - PGSIZE)</span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)((tf-&gt;tf_esp) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe) - <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		utf = (<span class="keyword">struct</span> UTrapframe *)(UXSTACKTOP - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe));</span><br><span class="line">	user_mem_assert(curenv, (<span class="type">void</span> *)utf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> UTrapframe), PTE_W);</span><br><span class="line">	utf-&gt;utf_fault_va = fault_va;</span><br><span class="line">	utf-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">	utf-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">	utf-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">	utf-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">	utf-&gt;utf_esp = tf-&gt;tf_esp;</span><br><span class="line">	curenv-&gt;env_tf.tf_eip = (<span class="type">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">	curenv-&gt;env_tf.tf_esp = (<span class="type">uintptr_t</span>)utf;</span><br><span class="line">	env_run(curenv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第8行为写入的权限检查，之后9-14行为<code>struct UTrapframe</code>整个结构体的压入，然后修改<code>curenv</code>里面的内容，转入<code>env_pgfault_upcall</code>当中执行。</p>
<p>如果没有<code>env_pgfault_upcall</code>的话，那么就执行<code>env_destroy()</code>的操作。</p>
<h2 id="exercise-10"><a class="markdownIt-Anchor" href="#exercise-10"></a> Exercise 10</h2>
<p>Exception Stack中的结构如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//	trap-time esp</span><br><span class="line">//	trap-time eflags</span><br><span class="line">//	trap-time eip</span><br><span class="line">//	utf_regs.reg_eax</span><br><span class="line">//	...</span><br><span class="line">//	utf_regs.reg_esi</span><br><span class="line">//	utf_regs.reg_edi</span><br><span class="line">//	utf_err (error code)</span><br><span class="line">//	utf_fault_va            &lt;-- %esp</span><br></pre></td></tr></table></figure>
<p>补全的<code>_pgfault_upcall</code>的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// LAB 4: Your code here.</span><br><span class="line">movl 0x28(%esp), %edi</span><br><span class="line">movl 0x30(%esp), %esi</span><br><span class="line">subl $4, %esi</span><br><span class="line">movl %edi, (%esi)</span><br><span class="line">movl %esi, 0x30(%esp)</span><br><span class="line"></span><br><span class="line">// Restore the trap-time registers.  After you do this, you</span><br><span class="line">// can no longer modify any general-purpose registers.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">addl $8, %esp</span><br><span class="line">popal</span><br><span class="line"></span><br><span class="line">// Restore eflags from the stack.  After you do this, you can</span><br><span class="line">// no longer use arithmetic operations or anything else that</span><br><span class="line">// modifies eflags.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">addl $4, %esp</span><br><span class="line">popfl</span><br><span class="line"></span><br><span class="line">// Switch back to the adjusted trap-time stack.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line">// Return to re-execute the instruction that faulted.</span><br><span class="line">// LAB 4: Your code here.</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>这里要实现栈切换同时需要保存<code>%eip</code>，首先在2、3行，将<code>%eip</code>取出放入<code>%edi</code>中，<code>%esp</code>取出放入<code>%esi</code>中，之后将<code>%esp</code>向下延伸一个word的大小，然后把<code>%eip</code>填入，之后将修改后的<code>%esp</code>放回保存的位置。</p>
<p>这样最终得到的<code>%esp</code>所指向的栈顶第一个元素就是我们之前所保存的<code>%eip</code>寄存器的值，就同时完成了栈的切换和<code>%eip</code>的恢复。后面就是不断退栈恢复寄存器的过程了，非常简单。</p>
<p>这里如果是在Exception Stack当中的重复调用，由于之前确保重复调用会在每两个结构之间留下一个word大小的gap，这个空隙就可以填入<code>%eip</code>保证以上的upcall在重复调用的情况下也能正常工作。</p>
<h2 id="exercise-11"><a class="markdownIt-Anchor" href="#exercise-11"></a> Exercise 11</h2>
<p>如果是第一次进行调用的话，那么需要进行初始化的设置，即给Exception Stack分配空间（17行），同时设置<code>pgfault_upcall</code>（19行）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the page fault handler function.</span></span><br><span class="line"><span class="comment">// If there isn&#x27;t one yet, _pgfault_handler will be 0.</span></span><br><span class="line"><span class="comment">// The first time we register a handler, we need to</span></span><br><span class="line"><span class="comment">// allocate an exception stack (one page of memory with its top</span></span><br><span class="line"><span class="comment">// at UXSTACKTOP), and tell the kernel to call the assembly-language</span></span><br><span class="line"><span class="comment">// _pgfault_upcall routine when a page fault occurs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">set_pgfault_handler</span><span class="params">(<span class="type">void</span> (*handler)(<span class="keyword">struct</span> UTrapframe *utf))</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="keyword">if</span>(sys_page_alloc(<span class="number">0</span>, (<span class="type">void</span> *)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P | PTE_W))</span><br><span class="line">			panic(<span class="string">&quot;set_pgfault_handler: page alloc fault!&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(sys_env_set_pgfault_upcall(<span class="number">0</span>, (<span class="type">void</span> *)_pgfault_upcall))</span><br><span class="line">			panic(<span class="string">&quot;set_pgfault handler: set pgfault upcall failed!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-12"><a class="markdownIt-Anchor" href="#exercise-12"></a> Exercise 12</h2>
<p><code>pgfault()</code> 可以参照dumbfork.c里面的<code>duppage()</code>，事实上dumbfork就是全部都进行一个复制，而COW的<code>fork()</code>只有在写入写时复制页面的时候才会进行复制，所以这里首先进行一个检查，看是不是写入一个COW页面所产生的错误。如果是的话，就分配一个新的页面并且将整个页面的内容拷贝一份，这里如注释中所写明的利用三次系统调用实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Custom page fault handler - if faulting page is copy-on-write,</span></span><br><span class="line"><span class="comment">// map in our own private writable copy.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">pgfault</span><span class="params">(<span class="keyword">struct</span> UTrapframe *utf)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *addr = (<span class="type">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="type">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">	<span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">	<span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>(!((err &amp; FEC_WR) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW)))</span><br><span class="line">		panic(<span class="string">&quot;pgfault: 0x%08x the fault page is not writable or copy-on-write page!&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">	<span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">	<span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_alloc(<span class="number">0</span>, PFTEMP, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;pgfault: sys_page_alloc fail, %e&quot;</span>, r);</span><br><span class="line">	memmove(PFTEMP, addr, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, PFTEMP, <span class="number">0</span>, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;pgfault: sys_page_map, %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;pgfault: sys_page_unmap, %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>duppage()</code>的实现就是按照注释中的内容进行，首先判断原本的页面是不是writable或者COW的，如果是的话那么就将其perm设置成写时复制的。之后现在子进程的地址空间中进行映射，再在父进程的地址空间中进行映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Map our virtual page pn (address pn*PGSIZE) into the target envid</span></span><br><span class="line"><span class="comment">// at the same virtual address.  If the page is writable or copy-on-write,</span></span><br><span class="line"><span class="comment">// the new mapping must be created copy-on-write, and then our mapping must be</span></span><br><span class="line"><span class="comment">// marked copy-on-write as well.  (Exercise: Why do we need to mark ours</span></span><br><span class="line"><span class="comment">// copy-on-write again if it was already copy-on-write at the beginning of</span></span><br><span class="line"><span class="comment">// this function?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">duppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">pte_t</span> pte = uvpt[pn];</span><br><span class="line">	<span class="type">void</span> * addr = (<span class="type">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> perm = pte &amp; <span class="number">0xFFF</span>;</span><br><span class="line">	<span class="keyword">if</span>(perm &amp; (PTE_W | PTE_COW))&#123;</span><br><span class="line">		perm &amp;= ~PTE_W;</span><br><span class="line">		perm |= PTE_COW;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, perm &amp; PTE_SYSCALL))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;duppage: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, perm &amp; PTE_SYSCALL))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;duppage: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>fork()</code>函数可以参照dumbfork的主体部分，由于只要赋值UTOP以下的地址空间，而Exception Stack是另外进行分配的，所以采用COW的复制方式到USTACKTOP就为止了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// User-level fork with copy-on-write.</span></span><br><span class="line"><span class="comment">// Set up our page fault handler appropriately.</span></span><br><span class="line"><span class="comment">// Create a child.</span></span><br><span class="line"><span class="comment">// Copy our address space and page fault handler setup to the child.</span></span><br><span class="line"><span class="comment">// Then mark the child as runnable and return.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns: child&#x27;s envid to the parent, 0 to the child, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// It is also OK to panic on error.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use uvpd, uvpt, and duppage.</span></span><br><span class="line"><span class="comment">//   Remember to fix &quot;thisenv&quot; in the child process.</span></span><br><span class="line"><span class="comment">//   Neither user exception stack should ever be marked copy-on-write,</span></span><br><span class="line"><span class="comment">//   so you must allocate a new page for the child&#x27;s user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">envid_t</span></span><br><span class="line"><span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">envid_t</span> envid;</span><br><span class="line">	<span class="type">uint8_t</span> * addr;</span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	<span class="keyword">if</span>(envid &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_exofork failed!&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(addr = (<span class="type">uint8_t</span> *)UTEXT; addr &lt;(<span class="type">uint8_t</span> *)USTACKTOP; addr += PGSIZE)</span><br><span class="line">		<span class="keyword">if</span>((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P))</span><br><span class="line">			duppage(envid, PGNUM(addr));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_alloc(envid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_W|PTE_P|PTE_U))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_page_alloc failed, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall();</span><br><span class="line">	<span class="keyword">if</span>((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)))</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_env_set_pgfault_upcall failed, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((r = sys_env_set_status(envid, ENV_RUNNABLE))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_env_set_status failed, %e&quot;</span>, r);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-13"><a class="markdownIt-Anchor" href="#exercise-13"></a> Exercise 13</h2>
<p>kern/trapentry.S和kern/trap.c当中由于我是用的是lab3里面challenge所描述的循环写法，这里并不需要做修改。</p>
<p>在kern/env.c的<code>env_alloc()</code>函数中设定EFLAG</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>
<p>在<code>sched_halt()</code>当中所需要注意的就是取消掉<code>sti</code>的注释，设置IF位使得空闲CPU并不会屏蔽中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asm volatile (</span><br><span class="line">	&quot;movl $0, %%ebp\n&quot;</span><br><span class="line">	&quot;movl %0, %%esp\n&quot;</span><br><span class="line">	&quot;pushl $0\n&quot;</span><br><span class="line">	&quot;pushl $0\n&quot;</span><br><span class="line">	// Uncomment the following line after completing exercise 13</span><br><span class="line">	&quot;sti\n&quot;</span><br><span class="line">	&quot;1:\n&quot;</span><br><span class="line">	&quot;hlt\n&quot;</span><br><span class="line">	&quot;jmp 1b\n&quot;</span><br><span class="line">: : &quot;a&quot; (thiscpu-&gt;cpu_ts.ts_esp0));</span><br></pre></td></tr></table></figure>
<h2 id="exercise-14"><a class="markdownIt-Anchor" href="#exercise-14"></a> Exercise 14</h2>
<p>只需要在<code>trap_dispatch()</code>当中添加分发的分支即可，这里需要按照注释内容在进行<code>sched_yield()</code>之前调用<code>lapic_eoi()</code>来确认中断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER)&#123;</span><br><span class="line">	lapic_eoi();</span><br><span class="line">	sched_yield();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exercise-15"><a class="markdownIt-Anchor" href="#exercise-15"></a> Exercise 15</h2>
<p><code>sys_ipc_recv()</code>当中主要做的操作就是首先进行参数的检查，检查完了之后将其填入env当中，并且让出CPU等待发送消息的进程将其重新设置为<code>RUNNABLE</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block until a value is ready.  Record that you want to receive</span></span><br><span class="line"><span class="comment">// using the env_ipc_recving and env_ipc_dstva fields of struct Env,</span></span><br><span class="line"><span class="comment">// mark yourself not runnable, and then give up the CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If &#x27;dstva&#x27; is &lt; UTOP, then you are willing to receive a page of data.</span></span><br><span class="line"><span class="comment">// &#x27;dstva&#x27; is the virtual address at which the sent page should be mapped.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This function only returns on error, but the system call will eventually</span></span><br><span class="line"><span class="comment">// return 0 on success.</span></span><br><span class="line"><span class="comment">// Return &lt; 0 on error.  Errors are:</span></span><br><span class="line"><span class="comment">//	-E_INVAL if dstva &lt; UTOP but dstva is not page-aligned.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_recv</span><span class="params">(<span class="type">void</span> *dstva)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">env</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(<span class="number">0</span>, &amp;env, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)dstva &lt; UTOP &amp;&amp; (dstva != ROUNDDOWN(dstva, PGSIZE)))</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	env-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	env-&gt;env_ipc_recving = <span class="literal">true</span>;</span><br><span class="line">	env-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	sys_yield();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_ipc_try_send()</code>的操作主要是对于注释里面所提到的所有可能的错误情形进行检查，当<code>srcva &lt; UTOP</code>的时候，和<code>sys_page_map()</code>当中的处理非常相似。在最终修改接收方env里面对应的值，并且将返回值设置成0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Try to send &#x27;value&#x27; to the target env &#x27;envid&#x27;.</span></span><br><span class="line"><span class="comment">// If srcva &lt; UTOP, then also send page currently mapped at &#x27;srcva&#x27;,</span></span><br><span class="line"><span class="comment">// so that receiver gets a duplicate mapping of the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send fails with a return value of -E_IPC_NOT_RECV if the</span></span><br><span class="line"><span class="comment">// target is not blocked, waiting for an IPC.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The send also can fail for the other reasons listed below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the send succeeds, and the target&#x27;s ipc fields are</span></span><br><span class="line"><span class="comment">// updated as follows:</span></span><br><span class="line"><span class="comment">//    env_ipc_recving is set to 0 to block future sends;</span></span><br><span class="line"><span class="comment">//    env_ipc_from is set to the sending envid;</span></span><br><span class="line"><span class="comment">//    env_ipc_value is set to the &#x27;value&#x27; parameter;</span></span><br><span class="line"><span class="comment">//    env_ipc_perm is set to &#x27;perm&#x27; if a page was transferred, 0 otherwise.</span></span><br><span class="line"><span class="comment">// The target environment is marked runnable again, returning 0</span></span><br><span class="line"><span class="comment">// from the paused sys_ipc_recv system call.  (Hint: does the</span></span><br><span class="line"><span class="comment">// sys_ipc_recv function ever actually return?)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the sender wants to send a page but the receiver isn&#x27;t asking for one,</span></span><br><span class="line"><span class="comment">// then no page mapping is transferred, but no error occurs.</span></span><br><span class="line"><span class="comment">// The ipc only happens when no errors occur.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns 0 on success, &lt; 0 on error.</span></span><br><span class="line"><span class="comment">// Errors are:</span></span><br><span class="line"><span class="comment">//	-E_BAD_ENV if environment envid doesn&#x27;t currently exist.</span></span><br><span class="line"><span class="comment">//		(No need to check permissions.)</span></span><br><span class="line"><span class="comment">//	-E_IPC_NOT_RECV if envid is not currently blocked in sys_ipc_recv,</span></span><br><span class="line"><span class="comment">//		or another environment managed to send first.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not page-aligned.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP and perm is inappropriate</span></span><br><span class="line"><span class="comment">//		(see sys_page_alloc).</span></span><br><span class="line"><span class="comment">//	-E_INVAL if srcva &lt; UTOP but srcva is not mapped in the caller&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="comment">//	-E_INVAL if (perm &amp; PTE_W), but srcva is read-only in the</span></span><br><span class="line"><span class="comment">//		current environment&#x27;s address space.</span></span><br><span class="line"><span class="comment">//	-E_NO_MEM if there&#x27;s not enough memory to map srcva in envid&#x27;s</span></span><br><span class="line"><span class="comment">//		address space.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sys_ipc_try_send</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">uint32_t</span> value, <span class="type">void</span> *srcva, <span class="type">unsigned</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">dstenv</span>, * <span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="keyword">if</span>(envid2env(envid, &amp;dstenv, <span class="number">0</span>) || envid2env(<span class="number">0</span>, &amp;srcenv, <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	<span class="keyword">if</span>(!dstenv-&gt;env_ipc_recving)</span><br><span class="line">		<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line">	dstenv-&gt;env_ipc_perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((<span class="type">uint32_t</span>)srcva &lt; UTOP)&#123;</span><br><span class="line">		<span class="type">pte_t</span> *pte;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line">		<span class="keyword">if</span>(srcva != ROUNDDOWN(srcva, PGSIZE))</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span>((perm &amp; (PTE_U | PTE_P)) != (PTE_U | PTE_P) || perm &amp; (~PTE_SYSCALL))</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span>(!(pp = page_lookup(srcenv-&gt;env_pgdir, srcva, &amp;pte)))</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span>((((*pte) &amp; PTE_W) == <span class="number">0</span>) &amp;&amp; (perm &amp; PTE_W))</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		<span class="keyword">if</span>(page_insert(dstenv-&gt;env_pgdir, pp, dstenv-&gt;env_ipc_dstva, perm))</span><br><span class="line">			<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">		dstenv-&gt;env_ipc_perm = perm;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dstenv-&gt;env_ipc_recving = <span class="literal">false</span>;</span><br><span class="line">	dstenv-&gt;env_ipc_value = value;</span><br><span class="line">	dstenv-&gt;env_ipc_from = srcenv-&gt;env_id;</span><br><span class="line">	dstenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	dstenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在lib/ipc.c当中要提供用户态可用的进行send和recv操作的接口。两个函数的相同之处在于如果没有传递地址映射的话，那么要讲地址设置成一个<code>UTOP</code>上方的值。</p>
<p>这里<code>ipc_recv()</code>只要根据返回值r进行两种情况的区分即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Receive a value via IPC and return it.</span></span><br><span class="line"><span class="comment">// If &#x27;pg&#x27; is nonnull, then any page sent by the sender will be mapped at</span></span><br><span class="line"><span class="comment">//	that address.</span></span><br><span class="line"><span class="comment">// If &#x27;from_env_store&#x27; is nonnull, then store the IPC sender&#x27;s envid in</span></span><br><span class="line"><span class="comment">//	*from_env_store.</span></span><br><span class="line"><span class="comment">// If &#x27;perm_store&#x27; is nonnull, then store the IPC sender&#x27;s page permission</span></span><br><span class="line"><span class="comment">//	in *perm_store (this is nonzero iff a page was successfully</span></span><br><span class="line"><span class="comment">//	transferred to &#x27;pg&#x27;).</span></span><br><span class="line"><span class="comment">// If the system call fails, then store 0 in *fromenv and *perm (if</span></span><br><span class="line"><span class="comment">//	they&#x27;re nonnull) and return the error.</span></span><br><span class="line"><span class="comment">// Otherwise, return the value sent by the sender</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use &#x27;thisenv&#x27; to discover the value and who sent it.</span></span><br><span class="line"><span class="comment">//   If &#x27;pg&#x27; is null, pass sys_ipc_recv a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning &quot;no page&quot;.  (Zero is not the right value, since that&#x27;s</span></span><br><span class="line"><span class="comment">//   a perfectly valid place to map a page.)</span></span><br><span class="line"><span class="type">int32_t</span></span><br><span class="line"><span class="title function_">ipc_recv</span><span class="params">(<span class="type">envid_t</span> *from_env_store, <span class="type">void</span> *pg, <span class="type">int</span> *perm_store)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	r = sys_ipc_recv(pg ? pg : (<span class="type">void</span> *)UTOP);</span><br><span class="line">	<span class="keyword">if</span>(r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(from_env_store)</span><br><span class="line">			*from_env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(perm_store)</span><br><span class="line">			*perm_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(from_env_store)</span><br><span class="line">			*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">		<span class="keyword">if</span>(perm_store)</span><br><span class="line">			*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">		<span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于<code>ipc_send()</code>则是通过一个循环来不断地尝试发送信息，为了防止一直占用CPU，每次循环中都会调用<code>sys_yield()</code>主动让出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send &#x27;val&#x27; (and &#x27;pg&#x27; with &#x27;perm&#x27;, if &#x27;pg&#x27; is nonnull) to &#x27;toenv&#x27;.</span></span><br><span class="line"><span class="comment">// This function keeps trying until it succeeds.</span></span><br><span class="line"><span class="comment">// It should panic() on any error other than -E_IPC_NOT_RECV.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use sys_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="comment">//   If &#x27;pg&#x27; is null, pass sys_ipc_try_send a value that it will understand</span></span><br><span class="line"><span class="comment">//   as meaning &quot;no page&quot;.  (Zero is not the right value.)</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_send</span><span class="params">(<span class="type">envid_t</span> to_env, <span class="type">uint32_t</span> val, <span class="type">void</span> *pg, <span class="type">int</span> perm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		sys_yield();</span><br><span class="line">		r = sys_ipc_try_send(to_env, val, pg ? pg : (<span class="type">void</span> *)UTOP, perm);</span><br><span class="line">		<span class="keyword">if</span>(r != <span class="number">0</span> &amp;&amp; r != -E_IPC_NOT_RECV)</span><br><span class="line">			panic(<span class="string">&quot;ipc_send: faild, %e&quot;</span>, r);</span><br><span class="line">	&#125;<span class="keyword">while</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现完了之后lab4的基础内容就已经结束了，执行<code>make grade</code>可以得到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin: OK (1.8s) </span><br><span class="line">stresssched: OK (3.2s) </span><br><span class="line">sendpage: OK (0.9s) </span><br><span class="line">    (Old jos.out.sendpage failure log removed)</span><br><span class="line">pingpong: OK (1.9s) </span><br><span class="line">    (Old jos.out.pingpong failure log removed)</span><br><span class="line">primes: OK (9.1s) </span><br><span class="line">    (Old jos.out.primes failure log removed)</span><br><span class="line">Part C score: 25/25</span><br><span class="line"></span><br><span class="line">Score: 80/80</span><br></pre></td></tr></table></figure>
<p>看到三部分都可以拿到全部分数。</p>
<h2 id="challenge-6-sfork"><a class="markdownIt-Anchor" href="#challenge-6-sfork"></a> Challenge 6: sfork()</h2>
<p>这一个challenge所要完成的是一个共享除了栈之外所有的地址空间的<code>fork</code>操作，记为<code>sfork()</code>。</p>
<p>首先实现了一个<code>sduppage()</code>函数，所做的是将父进程的地址映射给复制到子进程上，对于权限并不做修改，可以看做只是在<code>sys_page_map()</code>的基础上的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">sduppage</span><span class="params">(<span class="type">envid_t</span> envid, <span class="type">unsigned</span> pn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="type">pte_t</span> pte = uvpt[pn];</span><br><span class="line">	<span class="type">void</span> * addr = (<span class="type">void</span> *)(pn * PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> perm = pte &amp; <span class="number">0xFFF</span>;</span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, perm &amp; PTE_SYSCALL))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;sduppage: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就是<code>sfork()</code>函数的实现，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sfork</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">envid_t</span> envid;</span><br><span class="line">	<span class="type">uint8_t</span> * addr;</span><br><span class="line">	set_pgfault_handler(pgfault);</span><br><span class="line">	envid = sys_exofork();</span><br><span class="line">	<span class="keyword">if</span>(envid &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_exofork failed!&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(envid == <span class="number">0</span>)&#123;</span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> in_stack = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(addr = (<span class="type">uint8_t</span> *)(USTACKTOP - PGSIZE); addr &gt;= (<span class="type">uint8_t</span> *)UTEXT; addr -= PGSIZE)&#123;</span><br><span class="line">		<span class="keyword">if</span>((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P))&#123;</span><br><span class="line">			<span class="keyword">if</span>(in_stack)</span><br><span class="line">				duppage(envid, PGNUM(addr));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				sduppage(envid, PGNUM(addr));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			in_stack = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((r = sys_page_alloc(envid, (<span class="type">void</span> *)(UXSTACKTOP-PGSIZE), PTE_W|PTE_P|PTE_U))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_page_alloc failed, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">extern</span> <span class="type">void</span> _pgfault_upcall();</span><br><span class="line">	<span class="keyword">if</span>((r = sys_env_set_pgfault_upcall(envid, _pgfault_upcall)))</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_env_set_pgfault_upcall failed, %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((r = sys_env_set_status(envid, ENV_RUNNABLE))&lt;<span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;fork: sys_env_set_status failed, %e&quot;</span>, r);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到与之前所实现的<code>fork()</code>函数的主体相对比，区别只存在16-26行。这里从栈底往下来进行<code>duppage</code>的操作，当超过栈顶之后，<code>in_stack</code>会被设置成false，之后就是共享的地址空间，全部调用<code>sduppage()</code>。</p>
<p>到这里都是没有什么问题的，重点在于如何将<code>thisenv</code>这个全局变量能够使得不同的进程都能够得到其自身对应的Env结构体，否则的话，在<code>sfork()</code>的过程中，子进程会修改thisenv的指针。导致无论在父进程还是子进程当中，thisenv指向的都是子进程！</p>
<p>最为简单的想法就是通过<code>sys_getenvid()</code>系统调用得到<code>envid</code>，之后查找对应的Env结构体，由于两个进程共享地址空间，所以利用全局变量是不太方便的，一个简单方法是利用宏进行实现。</p>
<p>考虑第一种解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> thisenv ((const volatile struct Env *)(&amp;envs[ENVX(sys_getenvid())]))</span></span><br></pre></td></tr></table></figure>
<p>这种写法可以完成需求，但是他是一个地址，而在<code>libmain()</code>当中以及<code>fork()</code>当中都有对于<code>thisenv</code>进行初始化的操作，这样需要进行额外的代码修改。</p>
<p>第二种解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">realenv</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> thisenv (realenv = (const volatile struct Env *)(&amp;envs[ENVX(sys_getenvid())])), realenv</span></span><br></pre></td></tr></table></figure>
<p>利用逗号进行分隔，首先进行一个赋值操作，然后提供一个可以作为运算左值的对象，问题在于thisenv会被用作是<code>cprintf()</code>当中的参数，而逗号分隔会使得参数数量改变。</p>
<p>第三种解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">realenv</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> thisenv ((const volatile struct Env *)*((realenv = (const volatile struct Env *)(&amp;envs[ENVX(sys_getenvid())])), &amp;realenv))</span></span><br></pre></td></tr></table></figure>
<p>由于C中的逗号表达式以及赋值表达式所返回的都是值而不是对象，所以用先取地址再解引用的方式可以获得一个能作为运算左值的对象。这种方式理论上是没有问题的，但是由于当中会进行赋值操作，所以编译器会认为可能会导致结果出现偏差，会报warning。编译方式将warning视作error，所以这行不通。</p>
<p>最终采用的解决方案为利用一个新的指针数组存下所有Env结构体的地址，然后采用类似第一种解决方案的操作，不过得到的是一个可以作为赋值左值的对象。在inc/lib.c当中，添加关于<code>penvs</code>指针数组的声明，以及将<code>thisenv</code>作为一个宏进行声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">penvs</span>[<span class="title">NENV</span>];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> <span class="title">envs</span>[<span class="title">NENV</span>];</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> <span class="title">pages</span>[];</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> thisenv penvs[ENVX(sys_getenvid())]</span></span><br></pre></td></tr></table></figure>
<p>在lib/libmain.c当中声明<code>penvs</code>数组，并将其初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> * <span class="title">penvs</span>[<span class="title">NENV</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern const volatile struct Env *thisenv;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NENV; ++i)</span><br><span class="line">		penvs[i] = &amp;envs[i];</span><br></pre></td></tr></table></figure>
<p>在这样的操作下thisenv就可以完美兼容所有代码当中的情况了，不需要修改其他任何的实现。</p>
<p>执行pingpongs.c可以得到如下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">enabled interrupts: 1 2</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00001000] new env 00001001</span><br><span class="line">i am 00001000; thisenv is 0xeec00000</span><br><span class="line">send 0 from 1000 to 1001</span><br><span class="line">1001 got 0 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 1 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 2 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 3 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 4 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 5 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 6 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 7 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 8 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 9 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">[00001000] exiting gracefully</span><br><span class="line">[00001000] free env 00001000</span><br><span class="line">1001 got 10 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">[00001001] exiting gracefully</span><br><span class="line">[00001001] free env 00001001</span><br></pre></td></tr></table></figure>
<p>可以发现实际上两个进程确实是共享了地址空间，并且thisenv能够正确的指向进程自身了。</p>
<p>如果将其中的<code>sfork()</code>修改成<code>fork()</code>的话，得到的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enabled interrupts: 1 2</span><br><span class="line">[00000000] new env 00001000</span><br><span class="line">[00001000] new env 00001001</span><br><span class="line">i am 00001000; thisenv is 0xeec00000</span><br><span class="line">send 0 from 1000 to 1001</span><br><span class="line">1001 got 0 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 0 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 1 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 1 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 2 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 2 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 3 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 3 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">1001 got 4 from 1000 (thisenv is 0xeec0007c 1001)</span><br><span class="line">1000 got 4 from 1001 (thisenv is 0xeec00000 1000)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不同进程中的val值是不会共享的，综上测试可以说明<code>sfork()</code>的实现没有问题。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-828/" rel="tag"># 6.828</a>
              <a href="/tags/Operating-System/" rel="tag"># Operating System</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/04/26/CF-1341F/" rel="prev" title="Codeforces 1341F - Nastya and Time Machine">
      <i class="fa fa-chevron-left"></i> Codeforces 1341F - Nastya and Time Machine
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/07/CF-1342E/" rel="next" title="Codeforces 1342E - Placing Rooks">
      Codeforces 1342E - Placing Rooks <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-1"><span class="nav-number">1.</span> <span class="nav-text"> Exercise 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-2"><span class="nav-number">2.</span> <span class="nav-text"> Exercise 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question-1"><span class="nav-number">3.</span> <span class="nav-text"> Question 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-3"><span class="nav-number">4.</span> <span class="nav-text"> Exercise 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-4"><span class="nav-number">5.</span> <span class="nav-text"> Exercise 4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-5"><span class="nav-number">6.</span> <span class="nav-text"> Exercise 5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question-2"><span class="nav-number">7.</span> <span class="nav-text"> Question 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-6"><span class="nav-number">8.</span> <span class="nav-text"> Exercise 6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question-3"><span class="nav-number">9.</span> <span class="nav-text"> Question 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#question-4"><span class="nav-number">10.</span> <span class="nav-text"> Question 4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-7"><span class="nav-number">11.</span> <span class="nav-text"> Exercise 7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_exofork"><span class="nav-number">11.1.</span> <span class="nav-text"> sys_exofork()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_env_set_status"><span class="nav-number">11.2.</span> <span class="nav-text"> sys_env_set_status()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_page_alloc"><span class="nav-number">11.3.</span> <span class="nav-text"> sys_page_alloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_page_map"><span class="nav-number">11.4.</span> <span class="nav-text"> sys_page_map()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sys_page_unmap"><span class="nav-number">11.5.</span> <span class="nav-text"> sys_page_unmap()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-8"><span class="nav-number">12.</span> <span class="nav-text"> Exercise 8</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-9"><span class="nav-number">13.</span> <span class="nav-text"> Exercise 9</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-10"><span class="nav-number">14.</span> <span class="nav-text"> Exercise 10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-11"><span class="nav-number">15.</span> <span class="nav-text"> Exercise 11</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-12"><span class="nav-number">16.</span> <span class="nav-text"> Exercise 12</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-13"><span class="nav-number">17.</span> <span class="nav-text"> Exercise 13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-14"><span class="nav-number">18.</span> <span class="nav-text"> Exercise 14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exercise-15"><span class="nav-number">19.</span> <span class="nav-text"> Exercise 15</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#challenge-6-sfork"><span class="nav-number">20.</span> <span class="nav-text"> Challenge 6: sfork()</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pims</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pims</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
