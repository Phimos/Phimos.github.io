<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link href="https://cdn.bootcss.com/KaTeX/0.7.1/katex.min.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://phimos.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="写在前面 希望在寒假加上开学前两周自学完MIT 6.824课程，这个是MIT分布式系统的博士课程，应该也是分布式系统入门的神课。 采用的材料是2020Spring学期的材料，如果没有弃坑的话，对应的Lab解答都会同步更新到博客里面。 课程主页：http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;schedule.html 个人代码Repo：https:&#x2F;&#x2F;github.com">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.824 Lab1">
<meta property="og:url" content="http://phimos.github.io/2021/02/03/6824-lab1/index.html">
<meta property="og:site_name" content="Pims的博客">
<meta property="og:description" content="写在前面 希望在寒假加上开学前两周自学完MIT 6.824课程，这个是MIT分布式系统的博士课程，应该也是分布式系统入门的神课。 采用的材料是2020Spring学期的材料，如果没有弃坑的话，对应的Lab解答都会同步更新到博客里面。 课程主页：http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;schedule.html 个人代码Repo：https:&#x2F;&#x2F;github.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-03T08:55:54.000Z">
<meta property="article:modified_time" content="2021-02-03T08:55:54.000Z">
<meta property="article:author" content="Pims">
<meta property="article:tag" content="6.824">
<meta property="article:tag" content="Distributed System">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://phimos.github.io/2021/02/03/6824-lab1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>MIT6.824 Lab1 | Pims的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Pims的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pims的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://phimos.github.io/2021/02/03/6824-lab1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Pims">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pims的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT6.824 Lab1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-03 16:55:54" itemprop="dateCreated datePublished" datetime="2021-02-03T16:55:54+08:00">2021-02-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="写在前面"><a class="markdownIt-Anchor" href="#写在前面"></a> 写在前面</h2>
<p>希望在寒假加上开学前两周自学完MIT 6.824课程，这个是MIT分布式系统的博士课程，应该也是分布式系统入门的神课。</p>
<p>采用的材料是2020Spring学期的材料，<s>如果没有弃坑的话</s>，对应的Lab解答都会同步更新到博客里面。</p>
<p>课程主页：<a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2020/schedule.html">http://nil.csail.mit.edu/6.824/2020/schedule.html</a></p>
<p>个人代码Repo：<a target="_blank" rel="noopener" href="https://github.com/Phimos/6.824-2020Spring">https://github.com/Phimos/6.824-2020Spring</a></p>
<h2 id="实现过程"><a class="markdownIt-Anchor" href="#实现过程"></a> 实现过程</h2>
<p>Lab1的主要任务就是通过Golang来实现一个MapReduce的算法，具体的内容可以从Lab1的官方文档中获取。</p>
<p>首先定义任务的类型，具体如下，最关键的就是对应的类型/状态/编号。同时利用<code>MapFile</code>和<code>ReduceFiles</code>字段来提供对应任务的输入。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapReduceTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	TaskType   <span class="type">string</span> <span class="comment">// Map / Reduce / Wait</span></span><br><span class="line">	TaskStatus <span class="type">string</span> <span class="comment">// Unassigned / Assigned / Finished</span></span><br><span class="line">	TaskNum    <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	MapFile     <span class="type">string</span>   <span class="comment">// Input of Map task</span></span><br><span class="line">	ReduceFiles []<span class="type">string</span> <span class="comment">// Input of Reduce task</span></span><br><span class="line"></span><br><span class="line">	NumReduce <span class="type">int</span></span><br><span class="line">	NumMap    <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后定义RPC相关的参数和返回值，对于请求有两种，当是<code>finish</code>情况时，需要提供对应的<code>Task</code>字段便于修改Master里面的人物状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args for RPC</span></span><br><span class="line"><span class="keyword">type</span> MapReduceArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	MessageType <span class="type">string</span> <span class="comment">// request / finish</span></span><br><span class="line">	Task        MapReduceTask</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reply for RPC</span></span><br><span class="line"><span class="keyword">type</span> MapReduceReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	Task MapReduceTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Master的类型，实际上最关键的只有<code>MapTasks</code>、<code>ReduceTasks</code>以及<code>mu</code>三项，用来存储所有任务的状态。剩下的字段其实都可以根据任务的信息来进行统计，只是处于方便进行监测。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	NumMap            <span class="type">int</span></span><br><span class="line">	NumMapFinished    <span class="type">int</span></span><br><span class="line">	NumReduce         <span class="type">int</span></span><br><span class="line">	NumReduceFinished <span class="type">int</span></span><br><span class="line">	mu                sync.Mutex</span><br><span class="line"></span><br><span class="line">	MapTasks    []MapReduceTask</span><br><span class="line">	ReduceTasks []MapReduceTask</span><br><span class="line"></span><br><span class="line">	MapFinish    <span class="type">bool</span></span><br><span class="line">	ReduceFinish <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就根据Lab文档当中所给的Hints来梳理整个Lab1的内容。</p>
<blockquote>
<p>One way to get started is to modify <code>mr/worker.go</code>’s <code>Worker()</code> to send an RPC to the master asking for a task. Then modify the master to respond with the file name of an as-yet-unstarted map task. Then modify the worker to read that file and call the application Map function, as in <code>mrsequential.go</code>.</p>
</blockquote>
<p><code>Worker()</code>当中仿照样例里面的内容发送RPC请求，结果分为三类执行对应的<code>Map</code> 、<code>Reduce</code>、 <code>Wait</code>三类任务。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">	reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your worker implementation here.</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		args := MapReduceArgs&#123;MessageType: <span class="string">&quot;request&quot;</span>&#125;</span><br><span class="line">		reply := MapReduceReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">		resp := call(<span class="string">&quot;Master.MapReduceHandler&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !resp &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> reply.Task.TaskType &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;Map&quot;</span>:</span><br><span class="line">			mapTask(mapf, reply.Task)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;Reduce&quot;</span>:</span><br><span class="line">			reduceTask(reducef, reply.Task)</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&quot;Wait&quot;</span>:</span><br><span class="line">			waitTask()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Map的任务，主体部分直接参考<code>mrsequential.go</code>当中的代码，这里只需要从得到的task里面获取输入，并且修改对应的输出内容即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapTask</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue, task MapReduceTask) &#123;</span><br><span class="line">	filename := task.MapFile</span><br><span class="line"></span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	content, err := ioutil.ReadAll(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot read %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	file.Close()</span><br><span class="line"></span><br><span class="line">	kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">	kvaa := <span class="built_in">make</span>([][]KeyValue, task.NumReduce)</span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">		idx := ihash(kv.Key) % task.NumReduce</span><br><span class="line">		kvaa[idx] = <span class="built_in">append</span>(kvaa[idx], kv)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NumReduce; i++ &#123;</span><br><span class="line">		storeIntermediateFile(kvaa[i], intermediateFilename(task.TaskNum, i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> finishTask(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The application Map and Reduce functions are loaded at run-time using the Go plugin package, from files whose names end in <code>.so</code>.</p>
</blockquote>
<p>这边的话是通过<code>.so</code>文件来直接获取用于Map和Reduce过程的具体函数，包括最终进行test的脚本文件也是通过加载不同的<code>.so</code>来实现不同的测试效果，例如对crash情况的模拟。以下是<code>worker.go</code>中的对应的内容，直接通过已有的<code>loadPlugin()</code>进行加载就可以了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">		fmt.Fprintf(os.Stderr, <span class="string">&quot;Usage: mrworker xxx.so\n&quot;</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mapf, reducef := loadPlugin(os.Args[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	mr.Worker(mapf, reducef)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If you change anything in the <code>mr/</code> directory, you will probably have to re-build any MapReduce plugins you use, with something like <code>go build -buildmode=plugin ../mrapps/wc.go</code></p>
</blockquote>
<p>**这里每次都要重新build！**不然直接会出错，一开始没有注意到检查了挺久。</p>
<blockquote>
<p>This lab relies on the workers sharing a file system. That’s straightforward when all workers run on the same machine, but would require a global filesystem like GFS if the workers ran on different machines.</p>
</blockquote>
<p>由于是在同一台机器上去实现这样一个分布式的MapReduce方法，对文件系统实际上进行了一定程度的简化。</p>
<blockquote>
<p>A reasonable naming convention for intermediate files is <code>mr-X-Y</code>, where X is the Map task number, and Y is the reduce task number.</p>
</blockquote>
<p>这边利用一个函数来规范化对应<code>N x M</code>个中间文件的命名，具体的命名方式采用如上的<code>mr-X-Y</code>格式。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intermediateFilename</span><span class="params">(numMapTask <span class="type">int</span>, numReduceTask <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;mr-%v-%v&quot;</span>, numMapTask, numReduceTask)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The worker’s map task code will need a way to store intermediate key/value pairs in files in a way that can be correctly read back during reduce tasks. One possibility is to use Go’s <code>encoding/json</code> package. To write key/value pairs to a JSON file:</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := ... &#123;</span><br><span class="line">	err := enc.Encode(&amp;kv)</span><br></pre></td></tr></table></figure>
<p>and to read such a file back:</p>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">break</span> </span><br><span class="line">&#125;</span><br><span class="line">kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>正如在上面所提到的，利用<code>encoding/json</code>对于中间结果进行存取，只需要对于以上的代码进行简单修改即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">storeIntermediateFile</span><span class="params">(kva []KeyValue, filename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	file, err := os.Create(filename)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	enc := json.NewEncoder(file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;cannot create encoder&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">		err := enc.Encode(&amp;kv)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatal(<span class="string">&quot;cannot encode&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadIntermediateFile</span><span class="params">(filename <span class="type">string</span>)</span></span> []KeyValue &#123;</span><br><span class="line">	<span class="keyword">var</span> kva []KeyValue</span><br><span class="line">	file, err := os.Open(filename)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;cannot open %v&quot;</span>, filename)</span><br><span class="line">	&#125;</span><br><span class="line">	dec := json.NewDecoder(file)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		kv := KeyValue&#123;&#125;</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> kva</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The map part of your worker can use the <code>ihash(key)</code> function (in <code>worker.go</code>) to pick the reduce task for a given key.</p>
</blockquote>
<p>这是<code>mapTask()</code>当中对应的代码部分，在下面的第5行可以看到，通过<code>ihash(key) % nReduce</code>来得到对应的中间输出文件，进行中间结果的划分。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kva := mapf(filename, <span class="type">string</span>(content))</span><br><span class="line"></span><br><span class="line">kvaa := <span class="built_in">make</span>([][]KeyValue, task.NumReduce)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">	idx := ihash(kv.Key) % task.NumReduce</span><br><span class="line">	kvaa[idx] = <span class="built_in">append</span>(kvaa[idx], kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; task.NumReduce; i++ &#123;</span><br><span class="line">	storeIntermediateFile(kvaa[i], intermediateFilename(task.TaskNum, i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>You can steal some code from <code>mrsequential.go</code> for reading Map input files, for sorting intermedate key/value pairs between the Map and Reduce, and for storing Reduce output in files.</p>
</blockquote>
<p><s>读书人的事情，能够叫做偷吗</s></p>
<p>既然说了让抄，那就直接从<code>mrsequential.go</code>里面抄就好了，对应的输入输出需要进行修改，主体部分直接粘贴即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceTask</span><span class="params">(reducef <span class="keyword">func</span>(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>, task MapReduceTask) &#123;</span><br><span class="line">	<span class="keyword">var</span> intermediate []KeyValue</span><br><span class="line">	<span class="keyword">for</span> _, filename := <span class="keyword">range</span> task.ReduceFiles &#123;</span><br><span class="line">		intermediate = <span class="built_in">append</span>(intermediate, loadIntermediateFile(filename)...)</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(ByKey(intermediate))</span><br><span class="line">	oname := fmt.Sprintf(<span class="string">&quot;mr-out-%v&quot;</span>, task.TaskNum)</span><br><span class="line">	ofile, _ := os.Create(oname)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// call Reduce on each distinct key in intermediate[],</span></span><br><span class="line">	<span class="comment">// and print the result to mr-out-0.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(intermediate) &#123;</span><br><span class="line">		j := i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">			values = <span class="built_in">append</span>(values, intermediate[k].Value)</span><br><span class="line">		&#125;</span><br><span class="line">		output := reducef(intermediate[i].Key, values)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">		fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)</span><br><span class="line"></span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ofile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> finishTask(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The master, as an RPC server, will be concurrent; don’t forget to lock shared data.</p>
</blockquote>
<p>这里需要上锁的是Master，防止多个Worker进行同时的修改，我这里采用了一个非常暴力的大锁，在<code>MapReduceHandler()</code>的最开始对Master上锁，然后利用<code>defer</code>在函数退出之后进行锁的释放，保证每次只有一个<code>MapReduceHandler()</code>对Master当中的结构进行修改，确保对并发可以正确处理。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Your code here -- RPC handlers for the worker to call.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> MapReduceHandler(args *MapReduceArgs, reply *MapReduceReply) <span class="type">error</span> &#123;</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Use Go’s race detector, with <code>go build -race</code> and <code>go run -race</code>. <code>test-mr.sh</code> has a comment that shows you how to enable the race detector for the tests.</p>
</blockquote>
<p>这边是课上所提到的检验race的方法，go语言可以通过对于内存进行监控的情况来查看是否有race发生，但是不会被执行的代码当中的race错误是不会被分析出来的，因为go语言并没有对race进行一个静态的分析。</p>
<blockquote>
<p>Workers will sometimes need to wait, e.g. reduces can’t start until the last map has finished. One possibility is for workers to periodically ask the master for work, sleeping with <code>time.Sleep()</code> between each request. Another possibility is for the relevant RPC handler in the master to have a loop that waits, either with <code>time.Sleep()</code> or <code>sync.Cond</code>. Go runs the handler for each RPC in its own thread, so the fact that one handler is waiting won’t prevent the master from processing other RPCs.</p>
</blockquote>
<p>暂时还没有新的Task分配的状况，会在Map的任务已经全部分配下去但是还没有全部完成的情况出现。这个时候Master给Worker一个Wait的指令，通过<code>time.Sleep()</code>等待之后再次发送一个申请新任务的RPC请求。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The master can’t reliably distinguish between crashed workers, workers that are alive but have stalled for some reason, and workers that are executing but too slowly to be useful. The best you can do is have the master wait for some amount of time, and then give up and re-issue the task to a different worker. For this lab, have the master wait for ten seconds; after that the master should assume the worker has died (of course, it might not have).</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.MessageType == <span class="string">&quot;request&quot;</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !m.MapFinish &#123;</span><br><span class="line">		<span class="keyword">for</span> index, task := <span class="keyword">range</span> m.MapTasks &#123;</span><br><span class="line">			<span class="keyword">if</span> task.TaskStatus == <span class="string">&quot;Unassigned&quot;</span> &#123;</span><br><span class="line">				m.MapTasks[index].TaskStatus = <span class="string">&quot;Assigned&quot;</span></span><br><span class="line">				reply.Task = m.MapTasks[index]</span><br><span class="line">				<span class="keyword">go</span> m.checkTimeout(<span class="string">&quot;Map&quot;</span>, index, <span class="number">10</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reply.Task.TaskType = <span class="string">&quot;Wait&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> !m.ReduceFinish &#123;</span><br><span class="line">		<span class="keyword">for</span> index, task := <span class="keyword">range</span> m.ReduceTasks &#123;</span><br><span class="line">			<span class="keyword">if</span> task.TaskStatus == <span class="string">&quot;Unassigned&quot;</span> &#123;</span><br><span class="line">				m.ReduceTasks[index].TaskStatus = <span class="string">&quot;Assigned&quot;</span></span><br><span class="line">				reply.Task = m.ReduceTasks[index]</span><br><span class="line">				<span class="keyword">go</span> m.checkTimeout(<span class="string">&quot;Reduce&quot;</span>, index, <span class="number">10</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reply.Task.TaskType = <span class="string">&quot;Wait&quot;</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的<code>checkTimeout()</code>实现如下，就是进行一定时间的Sleep，之后检查任务是否完成，如果仍然没有完成处于<code>Assigned</code>状态的话，说明对应的Worker可能已经crash了。于是将其标为<code>Unassigned</code>状态，在之后进行重分配，保证MapReduce流程可以继续运行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> checkTimeout(taskType <span class="type">string</span>, num <span class="type">int</span>, timeout <span class="type">int</span>) &#123;</span><br><span class="line">	time.Sleep(time.Second * time.Duration(timeout))</span><br><span class="line">	m.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> taskType == <span class="string">&quot;Map&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> m.MapTasks[num].TaskStatus == <span class="string">&quot;Assigned&quot;</span> &#123;</span><br><span class="line">			m.MapTasks[num].TaskStatus = <span class="string">&quot;Unassigned&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> m.ReduceTasks[num].TaskStatus == <span class="string">&quot;Assigned&quot;</span> &#123;</span><br><span class="line">			m.ReduceTasks[num].TaskStatus = <span class="string">&quot;Unassigned&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>To test crash recovery, you can use the <code>mrapps/crash.go</code> application plugin. It randomly exits in the Map and Reduce functions.</p>
</blockquote>
<p>Test的最后一个部分就是crash test，会使用<code>crash.so</code>文件，事实上，在上面利用一个go routine取检查超时，如果一个worker在工作过程中crash了，那么就无法在最后返回个master一个<code>Finish</code>的RPC。所以利用以上的超时检查机制，是可以简单的对于Lab当中的crash进行正确重分配任务，保证MapReduce流程正常进行。</p>
<blockquote>
<p>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use <code>ioutil.TempFile</code> to create a temporary file and <code>os.Rename</code> to atomically rename it.</p>
</blockquote>
<p>这边只需要修改对应的输出为<code>TempFile -&gt; Rename</code>的流程就可以，这里就不进行修改了。</p>
<blockquote>
<p><code>test-mr.sh</code> runs all the processes in the sub-directory <code>mr-tmp</code>, so if something goes wrong and you want to look at intermediate or output files, look there.</p>
</blockquote>
<p>执行<code>sh test-mr.sh</code>的结果如下所示，可以发现对于Lab1的所有测试都完全通过。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*** Starting wc test.</span><br><span class="line">2021/02/03 16:24:03 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br><span class="line">--- wc test: PASS</span><br><span class="line">*** Starting indexer test.</span><br><span class="line">2021/02/03 16:24:09 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br><span class="line">--- indexer test: PASS</span><br><span class="line">*** Starting map parallelism test.</span><br><span class="line">2021/02/03 16:24:12 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br><span class="line">--- map parallelism test: PASS</span><br><span class="line">*** Starting reduce parallelism test.</span><br><span class="line">2021/02/03 16:24:20 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br><span class="line">--- reduce parallelism test: PASS</span><br><span class="line">*** Starting crash test.</span><br><span class="line">2021/02/03 16:24:28 rpc.Register: method &quot;Done&quot; has 1 input parameters; needs exactly three</span><br><span class="line">--- crash test: PASS</span><br><span class="line">*** PASSED ALL TESTS</span><br></pre></td></tr></table></figure>
<h2 id="体验"><a class="markdownIt-Anchor" href="#体验"></a> 体验</h2>
<ul>
<li>Golang上手的感觉还行，感觉和C语言差别不大，有C语言的基础熟悉一下语言特性应该就可以上手。</li>
<li>难度一般，可能是Lab1的缘故，总体实现上困难不是很大。</li>
<li>从文档和代码上看，整个Lab的结构上感觉没有6.828课程的巧妙，但是已经非常完备了，远超国内学校课程作业的实用程度。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/6-824/" rel="tag"># 6.824</a>
              <a href="/tags/Distributed-System/" rel="tag"># Distributed System</a>
              <a href="/tags/Golang/" rel="tag"># Golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/31/goodbye-2020/" rel="prev" title="Goodbye 2020">
      <i class="fa fa-chevron-left"></i> Goodbye 2020
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/18/trick-pytorch-rolling-window/" rel="next" title="[Trick] PyTorch构造滑动窗口">
      [Trick] PyTorch构造滑动窗口 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text"> 写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text"> 实现过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%93%E9%AA%8C"><span class="nav-number">3.</span> <span class="nav-text"> 体验</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Pims</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">60</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pims</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v7.3.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
